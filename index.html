<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MHWilds è£…å‚™ã‚·ãƒŸãƒ¥ï¼ˆWeb/CSVç›´èª­ï¼‹æ‰€æŒè£…é£¾å“ï¼‰</title>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<style>
  :root { --bg:#0b0f14; --fg:#e6edf3; --muted:#9aa4ad; --accent:#5ac8fa; --ok:#22c55e; --bad:#ef4444; --card:#111720; }
  html,body { margin:0; padding:0; background:var(--bg); color:var(--fg); font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP"; }
  header { padding:16px 20px; border-bottom:1px solid #1e2631; position:sticky; top:0; background:linear-gradient(180deg,var(--bg),rgba(11,15,20,.92)); backdrop-filter: blur(6px); z-index:2; }
  header h1 { margin:0; font-size:18px; }
  .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .grow { flex:1; }
  .muted { color:var(--muted); }
  .pill { display:inline-flex; align-items:center; gap:6px; background:#111b28; border:1px solid #233047; border-radius:999px; padding:4px 9px; font-size:12px; margin:0 8px 0 0; }
  input, select, button { background:#0e141c; color:var(--fg); border:1px solid #273142; border-radius:10px; padding:9px 10px; }
  input:focus, select:focus, button:focus { outline:1px solid var(--accent); }
  .btn { cursor:pointer; background:#142033; border:1px solid #223048; }
  .btn.primary { background:#13324b; border-color:#1d4566; }
  .btn.bad { background:#3b1116; border-color:#5e1c24; }
  .btn.ok  { background:#0f2e22; border-color:#175a46; }
  nav.tabs { display:flex; gap:8px; margin-top:10px; }
  nav.tabs button { padding:8px 12px; border-radius:10px; background:#101826; border:1px solid #223047; cursor:pointer; }
  nav.tabs button.active { background:#1a2740; border-color:#2c4470; }
  .wrap { display:grid; grid-template-columns: 1fr 1.1fr 1.2fr; gap:16px; padding:16px; }
  .wrap-full { padding:16px; }
  .card { background:var(--card); border:1px solid #1e2631; border-radius:14px; padding:14px; }
  h2 { margin:0 0 10px; font-size:16px; }
  .list { max-height: 300px; overflow:auto; padding-right:6px; }
  .small { font-size:12px; color:var(--muted); }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
  .success { color: var(--ok); font-weight:600; }
  .error { color: var(--bad); font-weight:600; }
  hr.sep { border:0; border-top:1px solid #223047; margin:12px 0; }
  .grid-2 { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
  .qty { width:80px; text-align:right; }
  @media (max-width: 1100px) { .wrap { grid-template-columns: 1fr; } }
</style>
</head>
<body>

<header>
  <div class="row">
    <div>
      <h1>MHWilds è£…å‚™ã‚·ãƒŸãƒ¥ï¼ˆWeb/CSVç›´èª­ï¼‰</h1>
      <div class="row" style="margin-top:8px;">
        <input id="sheetId" class="grow" placeholder="Google Sheet ID" />
        <button id="reload" class="btn">èª­è¾¼/æ›´æ–°</button>
        <span class="muted">ä¾‹: 19dqfEFxbwie8HISr2QH7P1alkxErZWJiZ-8cBKHg4RI</span>
      </div>
      <nav class="tabs">
        <button id="tab-sim" class="active">ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</button>
        <button id="tab-owned">æ‰€æŒè£…é£¾å“</button>
      </nav>
    </div>
    <div class="grow"></div>
    <div>
      <label class="row">
        <input type="checkbox" id="useOwned" />
        <span>æ‰€æŒè£…é£¾å“ã‚’è¨ˆç®—ã«åæ˜ </span>
      </label>
      <div class="small muted">ã‚ªãƒ³ã«ã™ã‚‹ã¨ã€å‰²ã‚Šå½“ã¦å¯èƒ½ãªè£…é£¾å“ã¯æ‰€æŒæ•°ã®ç¯„å›²å†…ã«ãªã‚Šã¾ã™ã€‚</div>
    </div>
  </div>
</header>

<!-- ====== ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ ====== -->
<main id="view-sim" class="wrap">
  <!-- å·¦ -->
  <section class="card">
    <h2>â‘  æ¬²ã—ã„ã‚¹ã‚­ãƒ«ã‚’é¸æŠ</h2>
    <div class="row">
      <input list="skillList" id="skillPicker" placeholder="ã‚¹ã‚­ãƒ«åã§æ¤œç´¢" class="grow" />
      <datalist id="skillList"></datalist>
      <button id="addSkill" class="btn">è¿½åŠ </button>
    </div>
    <div id="pickedSkills" style="margin-top:8px;"></div>
    <hr class="sep" />
    <h2>â‘¡ æ­¦å™¨ã‚’æŒ‡å®š</h2>
    <select id="weaponSelect" style="width:100%;"></select>
    <div class="small" id="weaponMeta"></div>
  </section>

  <!-- ä¸­å¤® -->
  <section class="card">
    <h2>â‘¢ å„ªå…ˆåº¦ï¼ˆ1=å¿…é ˆ / 2=ä¸‹ã’å¯ / 3=æ¶ˆã—ã¦ã‚‚å¯ï¼‰</h2>
    <div id="priorityPanel" class="list"></div>
    <hr class="sep" />
    <h2>â‘£ æ¤œç´¢</h2>
    <button id="run" class="btn primary">ã“ã®æ¡ä»¶ã§æ¤œç´¢ã™ã‚‹</button>
    <div style="margin-top:8px;">
      <label><input type="checkbox" id="optTryUpgrade" /> ä½™ã‚Šã‚¹ãƒ­ãƒƒãƒˆã§ã€ŒæŒ‡å®šã‚¹ã‚­ãƒ«ã®Lv+1ã€ã‚’æ¢ç´¢</label>
    </div>
  </section>

  <!-- å³ -->
  <section class="card">
    <h2>â‘¤ çµæœ</h2>
    <div id="result"></div>
    <hr class="sep" />
    <h2>â‘¥ ä¸æˆç«‹æ™‚ã®ææ¡ˆ</h2>
    <div id="fallback"></div>
  </section>
</main>

<!-- ====== æ‰€æŒè£…é£¾å“ ====== -->
<main id="view-owned" class="wrap-full" style="display:none;">
  <section class="card">
    <h2>æ‰€æŒè£…é£¾å“ã®ç®¡ç†</h2>
    <div class="grid-2" style="margin-top:8px;">
      <div>
        <label class="small muted">æ¤œç´¢ï¼ˆåç§° or ã‚¹ã‚­ãƒ«åï¼‰</label>
        <input id="ownedFilter" placeholder="ä¾‹: æ”»æ’ƒ or æ”»æ’ƒç " />
      </div>
      <div class="row" style="align-items:flex-end;">
        <button id="resetOwned" class="btn bad">å…¨ãƒªã‚»ãƒƒãƒˆï¼ˆ0ã«ï¼‰</button>
        <button id="exportOwned" class="btn">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆï¼ˆJSONï¼‰</button>
        <label class="btn">
          ã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼ˆJSON/CSVï¼‰
          <input id="importOwned" type="file" accept=".json,.csv" hidden />
        </label>
        <button id="maxOwned" class="btn ok">å…¨éƒ¨MAX</button>
      </div>
    </div>
    <div class="small" style="margin-top:6px;">â€» æ‰€æŒæ•°ã¯ãƒ–ãƒ©ã‚¦ã‚¶ã«ä¿å­˜ï¼ˆlocalStorageï¼‰ã€‚ã€Œæ‰€æŒè£…é£¾å“ã‚’è¨ˆç®—ã«åæ˜ ã€ã‚’ã‚ªãƒ³ã§åˆ¶é™ãŒåŠ¹ãã¾ã™ã€‚</div>
    <hr class="sep" />
    <div id="ownedList" class="list"></div>
  </section>
</main>

<script>
/** ===================== è¨­å®š ===================== **/
const DEFAULT_SHEET_ID = "19dqfEFxbwie8HISr2QH7P1alkxErZWJiZ-8cBKHg4RI";
const SHEETS = {
  weapons: "weapons_ja",
  armor: "armor_ja",
  decos: "decorations_ja",
  skills: "skills_ja",
  series: "series_bonus_ja",
};
const PRIORITY_WEIGHT = {1:100, 2:10, 3:1};
const LS_SHEET_ID = "mhw_sheet_id";
const LS_USE_OWNED = "mhw_use_owned";
const LS_OWNED_DECOS = "mhw_owned_decos";
const DEFAULT_OWNED_MAX = 99; // å…¨éƒ¨MAXã®åŸºæº–å€¤

function gsheetCsvUrl(sheetId, sheetName){
  return `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=${encodeURIComponent(sheetName)}`;
}

/** ===================== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ===================== **/
function parseSlots(text){
  if (!text || typeof text !== 'string') return [];
  return text.split('-').map(s=>parseInt(s.trim(),10)).filter(n=>!isNaN(n));
}
function canFit(slotSize, decoSlot){ // L3:1-3, L2:1-2, L1:1
  if (slotSize >= 3) return [1,2,3].includes(decoSlot);
  if (slotSize == 2) return [1,2].includes(decoSlot);
  return decoSlot === 1;
}
function normalizePartJaToKey(v){
  const s = (v||'').toString().trim();
  const map = {
    "é ­":"head","ãƒ˜ãƒƒãƒ‰":"head","Head":"head","é ­è£…å‚™":"head","é ­é˜²å…·":"head",
    "èƒ´":"chest","ãƒœãƒ‡ã‚£":"chest","Chest":"chest","èƒ´è£…å‚™":"chest",
    "è…•":"arms","ã‚¢ãƒ¼ãƒ ":"arms","Arms":"arms",
    "è…°":"waist","ã‚¦ã‚¨ã‚¹ãƒˆ":"waist","Waist":"waist",
    "è„š":"legs","ãƒ¬ãƒƒã‚°":"legs","Legs":"legs"
  };
  return map[s] || '';
}
function toInt(x, def=0){ const n = parseInt(x,10); return isNaN(n) ? def : n; }
function downloadText(filename, text){
  const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([text], {type:"text/plain"}));
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}

/** ===================== ã‚¹ã‚­ãƒ«æŠ½å‡ºï¼ˆå …ç‰¢ï¼‰ ===================== **/
// ä»˜ä¸ã‚¹ã‚­ãƒ«1 / ä»˜ä¸ã‚¹ã‚­ãƒ«1 SL, Lv, ãƒ¬ãƒ™ãƒ« ãªã©ã®è¡¨è¨˜ã‚†ã‚Œã‚’å¸å
function extractSkillsFromRow(row, namePrefix){
  const skills = {};
  const keys = Object.keys(row);
  const nameKeys = keys.filter(k => k.startsWith(namePrefix) && !/(SL|Lv|ãƒ¬ãƒ™ãƒ«)\s*$/i.test(k.trim()));
  for (const nk of nameKeys){
    const skName = (row[nk] || "").toString().trim();
    if (!skName) continue;
    const candLvKeys = [nk+" SL", nk+"SL", nk+"  SL", nk+" Lv", nk+"Lv", nk+" ãƒ¬ãƒ™ãƒ«"];
    let lv = 0;
    for (const lk of candLvKeys){
      if (lk in row) { lv = toInt(row[lk], 0); break; }
    }
    if (lv <= 0) lv = 1; // æœ€ä½1ã§ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆLvåˆ—æ¬ è½å¯¾ç­–ï¼‰
    skills[skName] = (skills[skName] || 0) + lv;
  }
  return skills;
}

/** ===================== ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ ===================== **/
async function loadCsv(url){
  const res = await fetch(url, {cache:'no-store'});
  const text = await res.text();
  return new Promise((resolve)=>{
    Papa.parse(text, { header:true, dynamicTyping:false, complete: (r)=>resolve(r.data) });
  });
}
async function loadAll(sheetId){
  const [wep, arm, dec, skl, ser] = await Promise.all([
    loadCsv(gsheetCsvUrl(sheetId, SHEETS.weapons)),
    loadCsv(gsheetCsvUrl(sheetId, SHEETS.armor)),
    loadCsv(gsheetCsvUrl(sheetId, SHEETS.decos)),
    loadCsv(gsheetCsvUrl(sheetId, SHEETS.skills)),
    loadCsv(gsheetCsvUrl(sheetId, SHEETS.series)),
  ]);
  return {wep, arm, dec, skl, ser};
}

/** ===================== ç´¢å¼•æ§‹ç¯‰ ===================== **/
function buildSkillRoster(skl){
  const out = {};
  for (const r of skl){
    const name = r["ã‚¹ã‚­ãƒ«å"];
    const mx = toInt(r["æœ€å¤§Lv"], null);
    if (name) out[name] = mx ?? null;
  }
  return out;
}
function buildWeaponIndex(wep){
  const idx = {};
  for (const r of wep){
    const name = r["æ­¦å™¨å"]; if (!name) continue;
    const slots = parseSlots(r["ã‚¹ãƒ­ãƒƒãƒˆ"]);
    const skills = extractSkillsFromRow(r, "æ­¦å™¨ã‚¹ã‚­ãƒ«");
    idx[name] = { slots, skills };
  }
  return idx;
}
function buildArmorIndex(arm){
  const byPart = {head:[],chest:[],arms:[],waist:[],legs:[]};
  for (const r of arm){
    const name = r["é˜²å…·å"]; const part = normalizePartJaToKey(r["éƒ¨ä½"]);
    if (!name || !part) continue;
    const slots = parseSlots(r["ã‚¹ãƒ­ãƒƒãƒˆ"]);
    const set_id = (r["ã‚»ãƒƒãƒˆID"] || "").toString();
    const skills = extractSkillsFromRow(r, "ä»˜ä¸ã‚¹ã‚­ãƒ«");
    byPart[part].push({ name, slots, skills, set_id });
  }
  return byPart;
}
function buildDecoIndexes(dec){
  const s2d = {};
  const catalog = [];
  for (const r of dec){
    const name = r["è£…é£¾å“å"]; const slot = toInt(r["ã‚¹ãƒ­ãƒƒãƒˆ"], 0);
    if (!name || !slot) continue;
    const skills = extractSkillsFromRow(r, "ä»˜ä¸ã‚¹ã‚­ãƒ«");
    for (const [sk, lv] of Object.entries(skills)){
      s2d[sk] = s2d[sk] || [];
      s2d[sk].push({ dname:name, slot, lv });
    }
    catalog.push({ name, slot, skills });
  }
  for (const sk of Object.keys(s2d)){
    s2d[sk].sort((a,b)=> (a.slot-b.slot) || (b.lv - a.lv) || a.dname.localeCompare(b.dname));
  }
  catalog.sort((a,b)=> (a.slot-b.slot) || a.name.localeCompare(b.name));
  return { s2d, catalog };
}
function buildSeriesIndex(ser){
  const mp = {};
  for (const r of ser){
    const sid = r["ã‚»ãƒƒãƒˆID"]; const req = toInt(r["å¿…è¦éƒ¨ä½æ•°"], 0); const sk = r["ã‚¹ã‚­ãƒ«å"]; const lv = toInt(r["Lv"], 0);
    if (!sid || !sk || !lv) continue;
    mp[sid] = mp[sid] || [];
    mp[sid].push({ required:req, skill:sk, lv });
  }
  return mp;
}

/** ===================== æ‰€æŒè£…é£¾å“ï¼ˆåœ¨åº«ç®¡ç†ï¼‰ ===================== **/
function loadOwnedDecos(){
  try{ return JSON.parse(localStorage.getItem(LS_OWNED_DECOS) || "{}"); }catch{ return {}; }
}
function saveOwnedDecos(map){ localStorage.setItem(LS_OWNED_DECOS, JSON.stringify(map||{})); }
function renderOwnedList(){
  const list = document.getElementById("ownedList");
  const q = (document.getElementById("ownedFilter").value||"").trim().toLowerCase();
  list.innerHTML="";
  const frag = document.createDocumentFragment();
  for (const d of DecoCatalog){
    const skillsText = Object.entries(d.skills).map(([k,v])=>`${k}+${v}`).join(", ");
    if (q){
      const hit = d.name.toLowerCase().includes(q) || skillsText.toLowerCase().includes(q);
      if (!hit) continue;
    }
    const row = document.createElement("div");
    row.className="row";
    row.style.marginBottom="8px";
    const meta = document.createElement("div");
    meta.className="grow small";
    meta.innerHTML = `<span class="pill mono">${d.name}</span> <span class="pill">slot${d.slot}</span> <span class="muted">${skillsText||'-'}</span>`;
    const input = document.createElement("input");
    input.type="number"; input.min="0"; input.step="1"; input.className="qty";
    input.value = OwnedDecos[d.name]||0;
    input.onchange = ()=>{ OwnedDecos[d.name] = Math.max(0, parseInt(input.value||"0",10)||0); saveOwnedDecos(OwnedDecos); };
    const plus = document.createElement("button"); plus.className="btn"; plus.textContent="+";
    plus.onclick = ()=>{ input.value = (parseInt(input.value||"0",10)||0)+1; input.onchange(); };
    const minus = document.createElement("button"); minus.className="btn"; minus.textContent="-";
    minus.onclick = ()=>{ input.value = Math.max(0,(parseInt(input.value||"0",10)||0)-1); input.onchange(); };
    row.appendChild(meta); row.appendChild(minus); row.appendChild(plus); row.appendChild(input);
    frag.appendChild(row);
  }
  list.appendChild(frag);
}
function importOwned(file){
  const reader = new FileReader();
  reader.onload = () => {
    try{
      let map = {};
      if (file.name.endsWith(".json")){
        map = JSON.parse(reader.result);
      }else{
        const res = Papa.parse(reader.result, {header:true});
        for (const r of res.data){
          const name = r["è£…é£¾å“å"] || r["name"] || r["è£…é£¾å“"] || r["deco"] || "";
          const n = parseInt(r["æ‰€æŒæ•°"] || r["count"] || r["qty"] || "0", 10);
          if (name) map[name]=Math.max(0, n||0);
        }
      }
      OwnedDecos = map;
      saveOwnedDecos(OwnedDecos);
      renderOwnedList();
      alert("æ‰€æŒè£…é£¾å“ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸã€‚");
    }catch(e){ alert("ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ: "+e.message); }
  };
  reader.readAsText(file);
}

/** ===================== ã‚³ã‚¢è¨ˆç®— ===================== **/
function greedyPickArmor(partsIndex, targets, priority){
  const order = ["head","chest","arms","waist","legs"];
  const picked = [];
  for (const part of order){
    const cand = partsIndex[part] || [];
    let best=null, bestScore=-1;
    for (const p of cand){
      let score = 0;
      for (const sk of Object.keys(targets)){
        const need = targets[sk];
        const w = PRIORITY_WEIGHT[ priority[sk] || 1 ] || 1;
        const gain = Math.min(need, p.skills[sk] || 0);
        score += gain * w;
      }
      score += 0.01 * (p.slots.reduce((a,b)=>a+b,0));
      if (score > bestScore){ bestScore=score; best=p; }
    }
    if (best) picked.push(best);
  }
  return picked;
}
function combineSkills(dicts){
  const out = {};
  for (const d of dicts){
    for (const [k,v] of Object.entries(d)) out[k]=(out[k]||0)+v;
  }
  return out;
}
function computeSeriesSkills(seriesIndex, pickedArmor){
  const cnt = {};
  for (const p of pickedArmor){
    const sid = p.set_id; if (!sid) continue;
    cnt[sid] = (cnt[sid]||0)+1;
  }
  const bonus = {};
  for (const [sid,n] of Object.entries(cnt)){
    for (const b of (seriesIndex[sid]||[])){
      if (n >= b.required) bonus[b.skill] = (bonus[b.skill]||0)+b.lv;
    }
  }
  return bonus;
}
function diffTargets(targets, have){
  const d = {};
  for (const [sk,need] of Object.entries(targets)){
    const hv = have[sk]||0;
    if (hv < need) d[sk] = need - hv;
  }
  return d;
}

// ç„¡åˆ¶é™
function fillWithDecorationsUnlimited(slotPool, deficits, skill2decos){
  const slots = [...slotPool].sort((a,b)=>b-a);
  const assign = [];
  for (const [sk, need0] of Object.entries(deficits)){
    let need = need0;
    const cand = skill2decos[sk];
    if (!cand) return { ok:false, assign, remain:slots, used:{} };
    while (need > 0){
      let placed = false;
      for (let i=0;i<slots.length;i++){
        const s = slots[i];
        const usable = cand.filter(d=>canFit(s, d.slot));
        if (!usable.length) continue;
        const pick = usable[0];
        const use = Math.min(need, pick.lv);
        assign.push({ skill: sk, deco: pick.dname, slot: s, lv: use });
        need -= use;
        slots.splice(i,1);
        placed = true;
        break;
      }
      if (!placed) return { ok:false, assign, remain:slots, used:{} };
    }
  }
  return { ok:true, assign, remain:slots, used:{} };
}

// æ‰€æŒæ•°åˆ¶é™ã‚ã‚Š
function fillWithDecorationsOwned(slotPool, deficits, skill2decos, ownedMap){
  const slots = [...slotPool].sort((a,b)=>b-a);
  const assign = [];
  const owned = JSON.parse(JSON.stringify(ownedMap || {}));
  const used = {};
  for (const [sk, need0] of Object.entries(deficits)){
    let need = need0;
    const cand = skill2decos[sk];
    if (!cand) return { ok:false, assign, remain:slots, used };
    while (need > 0){
      let placed = false;
      for (let i=0;i<slots.length;i++){
        const s = slots[i];
        const usable = cand.filter(d=> canFit(s, d.slot) && (owned[d.dname]||0) > 0);
        if (!usable.length) continue;
        const pick = usable[0];
        const use = Math.min(need, pick.lv);
        assign.push({ skill: sk, deco: pick.dname, slot: s, lv: use });
        need -= use;
        slots.splice(i,1);
        owned[pick.dname] = (owned[pick.dname]||0) - 1;
        used[pick.dname] = (used[pick.dname]||0) + 1;
        placed = true;
        break;
      }
      if (!placed) return { ok:false, assign, remain:slots, used };
    }
  }
  return { ok:true, assign, remain:slots, used };
}

/** ===================== ä¸è¶³ã‚¹ã‚­ãƒ«ã®ç™ºç”Ÿæºãƒ’ãƒ³ãƒˆ ===================== **/
function showDeficitHints(deficits){
  const fb = document.getElementById("fallback");
  const cont = document.createElement("div");
  cont.innerHTML = `<div class="muted">ä¸è¶³ã‚¹ã‚­ãƒ«ã®ç™ºç”Ÿæºãƒ’ãƒ³ãƒˆ</div>`;
  for (const [sk,need] of Object.entries(deficits)){
    const hasDeco = !!DIDX[sk];
    const tops = [];
    for (const part of ["head","chest","arms","waist","legs"]){
      const arr = (AIDX[part]||[])
        .filter(p=> (p.skills[sk]||0)>0)
        .sort((a,b)=> (b.skills[sk]||0) - (a.skills[sk]||0))
        .slice(0,2);
      arr.forEach(p=> tops.push(`${p.name}(+${p.skills[sk]})`));
    }
    const d = document.createElement("div");
    d.className="small";
    d.textContent = `- ${sk}: è£…é£¾å“=${hasDeco?'ã‚ã‚Š':'ãªã—'} ï¼ ä»£è¡¨é˜²å…·: ${tops.slice(0,5).join(", ") || "è©²å½“ãªã—"}`;
    cont.appendChild(d);
  }
  fb.appendChild(cont);
}

/** ===================== UIçŠ¶æ…‹ ===================== **/
const $ = (q)=>document.querySelector(q);
const skillRoster = {};
let WIDX={}, AIDX={}, DIDX={}, SIDX={};
let DecoCatalog=[];        // [{name, slot, skills}]
let OwnedDecos = {};       // {name: count}
const state = { picked:{}, priorities:{}, weapon:null };

/** ===================== åˆæœŸåŒ– ===================== **/
async function bootstrap(){
  // ã‚¿ãƒ–
  const tabSim = document.getElementById("tab-sim");
  const tabOwned = document.getElementById("tab-owned");
  const viewSim = document.getElementById("view-sim");
  const viewOwned = document.getElementById("view-owned");
  tabSim.onclick = ()=>{ tabSim.classList.add("active"); tabOwned.classList.remove("active"); viewSim.style.display="grid"; viewOwned.style.display="none"; };
  tabOwned.onclick = ()=>{ tabOwned.classList.add("active"); tabSim.classList.remove("active"); viewSim.style.display="none"; viewOwned.style.display="block"; };

  // ã‚·ãƒ¼ãƒˆID
  const sheetIdInput = $("#sheetId");
  sheetIdInput.value = localStorage.getItem(LS_SHEET_ID) || DEFAULT_SHEET_ID;
  $("#reload").onclick = async ()=>{
    localStorage.setItem(LS_SHEET_ID, sheetIdInput.value.trim());
    await loadAndIndex(sheetIdInput.value.trim());
  };

  // æ‰€æŒè£…é£¾å“ã®åæ˜ ãƒˆã‚°ãƒ«ï¼ˆæ—¢å®šã¯å‰å›å€¤ï¼æœªè¨­å®šã¯OFFï¼‰
  const useOwned = $("#useOwned");
  useOwned.checked = localStorage.getItem(LS_USE_OWNED) === "1";
  useOwned.onchange = ()=> localStorage.setItem(LS_USE_OWNED, useOwned.checked ? "1" : "0");

  // æ‰€æŒè£…é£¾å“ã®ã‚¤ãƒ™ãƒ³ãƒˆ
  $("#ownedFilter").oninput = ()=> renderOwnedList();
  $("#resetOwned").onclick = ()=>{ if (confirm("æ‰€æŒæ•°ã‚’å…¨ã¦0ã«ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ")) { OwnedDecos = {}; saveOwnedDecos(OwnedDecos); renderOwnedList(); } };
  $("#exportOwned").onclick = ()=> downloadText("owned_decorations.json", JSON.stringify(OwnedDecos, null, 2));
  $("#importOwned").onchange = (e)=>{ const f=e.target.files?.[0]; if (f) importOwned(f); e.target.value=""; };
  document.getElementById("maxOwned").onclick = ()=>{
    if (!confirm("å…¨è£…é£¾å“ã®æ‰€æŒæ•°ã‚’MAXã«ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ")) return;
    for (const d of DecoCatalog) OwnedDecos[d.name] = DEFAULT_OWNED_MAX;
    saveOwnedDecos(OwnedDecos);
    renderOwnedList();
  };

  // ã‚¹ã‚­ãƒ«è¿½åŠ 
  $("#addSkill").onclick = ()=>{
    const name = $("#skillPicker").value.trim();
    if (!name || !(name in skillRoster)) return;
    if (!state.picked[name]) state.picked[name] = { target: Math.min(3, skillRoster[name]||3), max: (skillRoster[name]||null) };
    if (!state.priorities[name]) state.priorities[name]=1;
    $("#skillPicker").value="";
    renderPicked(); renderPriorityPanel();
  };

  // æ­¦å™¨é¸æŠ
  $("#weaponSelect").onchange = ()=>{
    const val = $("#weaponSelect").value;
    state.weapon = val || null;
    const meta = $("#weaponMeta"); meta.innerHTML="";
    if (state.weapon){
      const w = WIDX[state.weapon];
      meta.innerHTML = `<div class="small">ã‚¹ãƒ­ãƒƒãƒˆ: <span class="mono">${w.slots.join("-")||"-"}</span> ï¼ æ­¦å™¨ã‚¹ã‚­ãƒ«: ${Object.keys(w.skills).length? JSON.stringify(w.skills):"ãªã—"}</div>`;
    }
  };

  // å®Ÿè¡Œ
  $("#run").onclick = ()=> runSearch();

  // æ—¢å­˜ã®æ‰€æŒãƒ‡ãƒ¼ã‚¿ã‚’ãƒ­ãƒ¼ãƒ‰
  OwnedDecos = loadOwnedDecos();

  // åˆå›ãƒ­ãƒ¼ãƒ‰
  await loadAndIndex(sheetIdInput.value.trim());
}

async function loadAndIndex(sheetId){
  const out = $("#result"); out.textContent="èª­ã¿è¾¼ã¿ä¸­...";
  const fb = $("#fallback"); fb.textContent="";
  try{
    const {wep, arm, dec, skl, ser} = await loadAll(sheetId);
    // ç´¢å¼•
    Object.assign(skillRoster, buildSkillRoster(skl));
    WIDX = buildWeaponIndex(wep);
    AIDX = buildArmorIndex(arm);
    const d = buildDecoIndexes(dec);
    DIDX = d.s2d; DecoCatalog = d.catalog;
    SIDX = buildSeriesIndex(ser);

    // åˆå›ã®ã¿ï¼šæ‰€æŒè£…é£¾å“ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆMAXã§åˆæœŸåŒ–
    if (!localStorage.getItem(LS_OWNED_DECOS)) {
      OwnedDecos = {};
      for (const deco of DecoCatalog) OwnedDecos[deco.name] = DEFAULT_OWNED_MAX;
      saveOwnedDecos(OwnedDecos);
    }

    // UIæç”»
    renderSkillPicker();
    renderWeapons();
    renderOwnedList();

    // èª­ã¿è¾¼ã¿ã‚µãƒãƒª
    const cnt = {
      head: AIDX.head.length, chest: AIDX.chest.length, arms: AIDX.arms.length,
      waist: AIDX.waist.length, legs: AIDX.legs.length
    };
    out.innerHTML =
      `ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å®Œäº†ã€‚æ¡ä»¶ã‚’æŒ‡å®šã—ã¦æ¤œç´¢ã—ã¦ãã ã•ã„ã€‚<br>` +
      `<span class="small muted">é˜²å…·ä»¶æ•°: é ­${cnt.head} èƒ´${cnt.chest} è…•${cnt.arms} è…°${cnt.waist} è„š${cnt.legs} ï¼ `+
      `æ­¦å™¨: ${Object.keys(WIDX).length} ï¼ è£…é£¾å“: ${DecoCatalog.length}</span>`;
  }catch(e){
    out.innerHTML = `<span class="error">ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã§ã‚¨ãƒ©ãƒ¼: ${e?.message||e}</span>`;
  }
}

/** ===================== æç”» ===================== **/
function renderSkillPicker(){
  const dl = $("#skillList");
  dl.innerHTML = "";
  Object.keys(skillRoster).sort().forEach(n=>{
    const opt = document.createElement("option"); opt.value = n; dl.appendChild(opt);
  });
}
function renderWeapons(){
  const sel = $("#weaponSelect"); sel.innerHTML="";
  const none = document.createElement("option"); none.value=""; none.textContent="ï¼ˆæœªé¸æŠï¼‰";
  sel.appendChild(none);
  Object.keys(WIDX).sort().forEach(n=>{
    const op = document.createElement("option"); op.value=n; op.textContent=n; sel.appendChild(op);
  });
}
function renderPicked(){
  const box = $("#pickedSkills"); box.innerHTML="";
  Object.entries(state.picked).forEach(([sk,info])=>{
    const wrap = document.createElement("div");
    wrap.className="row"; wrap.style.alignItems="center";
    const label = document.createElement("div");
    label.className="pill"; label.innerHTML = `<span>${sk}</span><span class="muted">max:${info.max??"?"}</span>`;
    const input = document.createElement("input");
    input.type="range"; input.min="1"; input.max=(info.max||10); input.value=info.target; input.className="grow";
    input.oninput=()=>{ state.picked[sk].target = parseInt(input.value,10); renderPriorityPanel(); };
    const num = document.createElement("span"); num.className="pill"; num.textContent = `Lv${info.target}`;
    input.addEventListener("input", ()=> num.textContent = `Lv${input.value}`);
    const del = document.createElement("button"); del.className="btn bad"; del.textContent="å‰Šé™¤";
    del.onclick=()=>{ delete state.picked[sk]; delete state.priorities[sk]; renderPicked(); renderPriorityPanel(); };
    wrap.appendChild(label); wrap.appendChild(input); wrap.appendChild(num); wrap.appendChild(del);
    box.appendChild(wrap);
  });
}
function renderPriorityPanel(){
  const box = $("#priorityPanel"); box.innerHTML="";
  Object.keys(state.picked).forEach(sk=>{
    const row = document.createElement("div"); row.className="row";
    const lbl = document.createElement("div"); lbl.className="pill"; lbl.textContent=sk;
    const sel = document.createElement("select");
    [1,2,3].forEach(v=>{
      const op = document.createElement("option"); op.value=v; op.textContent=v;
      if ((state.priorities[sk]||1)===v) op.selected=true;
      sel.appendChild(op);
    });
    sel.onchange=()=>{ state.priorities[sk]=parseInt(sel.value,10); };
    row.appendChild(lbl); row.appendChild(sel);
    box.appendChild(row);
  });
}

/** ===================== å®Ÿè¡Œ ===================== **/
function runSearch(){
  const res = $("#result"); const fb = $("#fallback"); res.innerHTML=""; fb.innerHTML="";
  const targets = {}; const prio = {};
  Object.entries(state.picked).forEach(([sk,info])=> targets[sk]=info.target);
  Object.entries(state.priorities).forEach(([sk,v])=> prio[sk]=v);

  const wslots = state.weapon ? WIDX[state.weapon].slots : [];
  const wskills = state.weapon ? WIDX[state.weapon].skills : {};

  // 5éƒ¨ä½Greedy
  const picked = greedyPickArmor(AIDX, targets, prio);

  // è¡¨ç¤ºã®ãƒ™ãƒ¼ã‚¹
  const list = document.createElement("div");
  list.innerHTML = `<div class="muted">é¸æŠé˜²å…·ï¼ˆGreedyï¼‰</div>`;
  picked.forEach(p=>{
    const d = document.createElement("div");
    d.className="small mono";
    d.textContent = `- ${p.name}  slots=${p.slots.join('-')||'-'}  skills=${JSON.stringify(p.skills)}  set=${p.set_id||''}`;
    list.appendChild(d);
  });
  if (!picked.length){
    const warn = document.createElement("div");
    warn.className = "small error";
    warn.textContent = "é˜²å…·å€™è£œãŒ0ä»¶ã§ã™ã€‚armor_jaã®ãƒ˜ãƒƒãƒ€ãƒ¼ã‚„éƒ¨ä½åã®å–ã‚Šè¾¼ã¿ã«å¤±æ•—ã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚";
    list.appendChild(warn);
  }
  res.appendChild(list);

  // åˆç®—
  let allSlots = [...wslots];
  for (const p of picked) allSlots.push(...p.slots);
  const total = combineSkills([wskills, ...picked.map(p=>p.skills)]);
  const ser = computeSeriesSkills(SIDX, picked);
  for (const [k,v] of Object.entries(ser)) total[k]=(total[k]||0)+v;

  const deficits = diffTargets(targets, total);

  const useOwned = document.getElementById("useOwned").checked;
  const filled = useOwned
    ? fillWithDecorationsOwned(allSlots, deficits, DIDX, OwnedDecos)
    : fillWithDecorationsUnlimited(allSlots, deficits, DIDX);

  if (Object.keys(ser).length){
    const d = document.createElement("div");
    d.className="small"; d.textContent = `ã‚·ãƒªãƒ¼ã‚ºç™ºå‹•: ${JSON.stringify(ser)}`;
    res.appendChild(d);
  }
  if (useOwned){
    const d = document.createElement("div");
    d.className="small muted";
    d.textContent = "â€» æ‰€æŒè£…é£¾å“åˆ¶é™ã‚’åæ˜ ä¸­";
    res.appendChild(d);
  }

  if (filled.ok){
    const ok = document.createElement("div");
    ok.className="success"; ok.textContent="ğŸ‰ ç›®æ¨™ã‚¹ã‚­ãƒ«ã‚’æº€ãŸã›ã¾ã—ãŸ";
    res.appendChild(ok);

    const tbl = document.createElement("div");
    tbl.innerHTML = `<div class="muted">è£…é£¾å“ã‚¢ã‚µã‚¤ãƒ³ï¼ˆskill / deco / slot / +lvï¼‰</div>`;
    for (const a of filled.assign){
      const d = document.createElement("div"); d.className="small mono";
      d.textContent = `- ${a.skill} / ${a.deco} / slot${a.slot} / +${a.lv}`;
      tbl.appendChild(d);
    }
    res.appendChild(tbl);

    if (useOwned && Object.keys(filled.used||{}).length){
      const u = document.createElement("div");
      u.innerHTML = `<div class="muted">ä»Šå›æ¶ˆè²»ã—ãŸæ‰€æŒè£…é£¾å“</div>`;
      for (const [nm,c] of Object.entries(filled.used)){
        const d = document.createElement("div"); d.className="small mono";
        d.textContent = `- ${nm}: ${c}å€‹`;
        u.appendChild(d);
      }
      res.appendChild(u);
    }

    if (document.getElementById("optTryUpgrade").checked){
      const remain = filled.remain;
      const upDiv = document.createElement("div");
      upDiv.innerHTML = `<div class="muted">è¿½åŠ ã§ç››ã‚Œã‚‹ã‹æ¢ç´¢</div>`;
      let found = false;
      for (const sk of Object.keys(targets)){
        const cur = (total[sk]||0) + filled.assign.filter(a=>a.skill===sk).reduce((s,a)=>s+a.lv,0);
        const mx  = (skillRoster[sk] || 10);
        if (cur < mx){
          const tryAdd = useOwned
            ? fillWithDecorationsOwned(remain, {[sk]:1}, DIDX, OwnedDecos)
            : fillWithDecorationsUnlimited(remain, {[sk]:1}, DIDX);
          if (tryAdd.ok && tryAdd.assign.length){
            found = true;
            const a = tryAdd.assign[0];
            const d = document.createElement("div"); d.className="small mono";
            d.textContent = `- ${sk} / ${a.deco} / slot${a.slot} / +${a.lv}`;
            upDiv.appendChild(d);
          }
        }
      }
      if (!found){
        const nd = document.createElement("div"); nd.className="small muted"; nd.textContent="è¿½åŠ å€™è£œã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚";
        upDiv.appendChild(nd);
      }
      res.appendChild(upDiv);
    }

  }else{
    const bad = document.createElement("div");
    bad.className="error"; bad.textContent="ç›®æ¨™ã‚¹ã‚­ãƒ«ã‚’æº€ãŸã›ã¾ã›ã‚“ã§ã—ãŸã€‚";
    res.appendChild(bad);

    const def = document.createElement("div");
    def.className="small mono";
    def.textContent = "ä¸è¶³: " + JSON.stringify(deficits);
    res.appendChild(def);

    if (useOwned && Object.keys(filled.used||{}).length){
      const u = document.createElement("div");
      u.innerHTML = `<div class="muted">ä»Šå›æ¶ˆè²»ã§ããŸæ‰€æŒè£…é£¾å“ï¼ˆä¸è¶³ã®ãŸã‚æœªé”ï¼‰</div>`;
      for (const [nm,c] of Object.entries(filled.used)){
        const d = document.createElement("div"); d.className="small mono";
        d.textContent = `- ${nm}: ${c}å€‹ä½¿ç”¨`;
        u.appendChild(d);
      }
      res.appendChild(u);
    }

    // å¦¥å”ææ¡ˆï¼ˆç°¡æ˜“ï¼‰
    const lowable = Object.entries(prio).filter(([sk,p])=> p>=2 && deficits[sk]).map(([sk])=>sk);
    const w = document.createElement("div");
    w.innerHTML = `<div class="muted">â‘¥-1 ææ¡ˆï¼šå„ªå…ˆåº¦2/3ã®ã‚¹ã‚­ãƒ«ã‚’ä¸‹ã’ã‚‹ã¨æˆç«‹ã™ã‚‹å¯èƒ½æ€§ã‚ã‚Š</div>
                   <div class="small mono">ä¸‹ã’å€™è£œ: ${lowable.length? lowable.join(", ") : "è©²å½“ãªã—"}</div>`;
    document.getElementById("fallback").appendChild(w);

    const t = document.createElement("div");
    t.className="small muted";
    t.textContent = "â‘¥-2 é‘‘å®šè­·çŸ³ææ¡ˆï¼šã‚·ãƒ¼ãƒˆãŒç”¨æ„ã•ã‚Œã¦ã„ã‚Œã°æ‹¡å¼µå¯èƒ½ï¼ˆæœ¬MVPã¯çœç•¥ï¼‰";
    document.getElementById("fallback").appendChild(t);
  }

  // â˜… ä¸è¶³ã‚¹ã‚­ãƒ«ã®ç™ºç”Ÿæºãƒ’ãƒ³ãƒˆã‚’æœ€å¾Œã«å‡ºã™
  if (Object.keys(deficits).length) showDeficitHints(deficits);
}

/** ===================== èµ·å‹• ===================== **/
function initialUI(){
  const dl = $("#skillList"); dl.innerHTML="";
  $("#weaponSelect").innerHTML = `<option value="">ï¼ˆæœªé¸æŠï¼‰</option>`;
}
initialUI();
bootstrap();
</script>
</body>
</html>
