<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MHWilds è£…å‚™ã‚·ãƒŸãƒ¥ï¼ˆåˆè¨ˆã‚¹ã‚­ãƒ«ï¼†ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼è¡¨ç¤ºï¼‰</title>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<style>
  :root { --bg:#0b0f14; --fg:#e6edf3; --muted:#9aa4ad; --accent:#5ac8fa; --ok:#22c55e; --bad:#ef4444; --warn:#f59e0b; --card:#111720; }
  html,body { margin:0; padding:0; background:var(--bg); color:var(--fg); font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP"; }
  header { padding:16px 20px; border-bottom:1px solid #1e2631; position:sticky; top:0; background:linear-gradient(180deg,var(--bg),rgba(11,15,20,.92)); backdrop-filter: blur(6px); z-index:2; }
  header h1 { margin:0; font-size:18px; }
  .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .grow { flex:1; }
  .muted { color:var(--muted); }
  .pill { display:inline-flex; align-items:center; gap:6px; background:#111b28; border:1px solid #233047; border-radius:999px; padding:4px 9px; font-size:12px; margin:0 8px 0 0; }
  input, select, button { background:#0e141c; color:var(--fg); border:1px solid #273142; border-radius:10px; padding:9px 10px; }
  input:focus, select:focus, button:focus { outline:1px solid var(--accent); }
  .btn { cursor:pointer; background:#142033; border:1px solid #223048; }
  .btn.primary { background:#13324b; border-color:#1d4566; }
  .btn.bad { background:#3b1116; border-color:#5e1c24; }
  .btn.ok  { background:#0f2e22; border-color:#175a46; }
  nav.tabs { display:flex; gap:8px; margin-top:10px; }
  nav.tabs button { padding:8px 12px; border-radius:10px; background:#101826; border:1px solid #223047; cursor:pointer; }
  nav.tabs button.active { background:#1a2740; border-color:#2c4470; }
  .wrap { display:grid; grid-template-columns: 1fr 1.1fr 1.2fr; gap:16px; padding:16px; }
  .wrap-full { padding:16px; }
  .card { background:var(--card); border:1px solid #1e2631; border-radius:14px; padding:14px; }
  h2 { margin:0 0 10px; font-size:16px; }
  h3 { margin:8px 0 6px; font-size:14px; }
  .list { max-height: 300px; overflow:auto; padding-right:6px; }
  .small { font-size:12px; color:var(--muted); }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
  .success { color: var(--ok); font-weight:600; }
  .error { color: var(--bad); font-weight:600; }
  .warn { color: var(--warn); font-weight:600; }
  hr.sep { border:0; border-top:1px solid #223047; margin:12px 0; }
  .grid-2 { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
  .qty { width:80px; text-align:right; }
  table { width:100%; border-collapse: collapse; }
  th, td { padding:6px 8px; border-bottom:1px solid #223047; font-size:13px; vertical-align: top; }
  th { text-align:left; color:#c7d2da; }
  .tag { display:inline-block; padding:2px 6px; border:1px solid #27405f; border-radius:6px; margin:0 6px 6px 0; font-size:12px; background:#0f1826; }
  .overcap { color: var(--bad); font-weight:700; }
  .overtarget { color: var(--warn); font-weight:700; }
  details summary { cursor:pointer; user-select:none; }
  @media (max-width: 1100px) { .wrap { grid-template-columns: 1fr; } }
</style>
</head>
<body>

<header>
  <div class="row">
    <div>
      <h1>MHWilds è£…å‚™ã‚·ãƒŸãƒ¥ï¼ˆCSVç›´èª­ãƒ»åœ¨åº«å¯¾å¿œãƒ»åˆè¨ˆ/ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼è¡¨ç¤ºï¼‰</h1>
      <div class="row" style="margin-top:8px;">
        <input id="sheetId" class="grow" placeholder="Google Sheet ID" />
        <button id="reload" class="btn">èª­è¾¼/æ›´æ–°</button>
        <span class="muted">ä¾‹: 19dqfEFxbwie8HISr2QH7P1alkxErZWJiZ-8cBKHg4RI</span>
      </div>
      <nav class="tabs">
        <button id="tab-sim" class="active">ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</button>
        <button id="tab-owned">æ‰€æŒè£…é£¾å“</button>
      </nav>
    </div>
    <div class="grow"></div>
    <div>
      <label class="row">
        <input type="checkbox" id="useOwned" />
        <span>æ‰€æŒè£…é£¾å“ã‚’è¨ˆç®—ã«åæ˜ </span>
      </label>
      <div class="small muted">ã‚ªãƒ³ã§åœ¨åº«åˆ¶é™ã‚’é©ç”¨ï¼ˆæœªã‚ªãƒ³ã¯ç„¡åˆ¶é™ï¼‰</div>
    </div>
  </div>
</header>

<!-- ====== ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ ====== -->
<main id="view-sim" class="wrap">
  <!-- å·¦ -->
  <section class="card">
    <h2>â‘  æ¬²ã—ã„ã‚¹ã‚­ãƒ«ã‚’é¸æŠ</h2>
    <div class="row">
      <input list="skillList" id="skillPicker" placeholder="ã‚¹ã‚­ãƒ«åã§æ¤œç´¢" class="grow" />
      <datalist id="skillList"></datalist>
      <button id="addSkill" class="btn">è¿½åŠ </button>
    </div>
    <div id="pickedSkills" style="margin-top:8px;"></div>
    <hr class="sep" />
    <h2>â‘¡ æ­¦å™¨ã‚’æŒ‡å®š</h2>
    <select id="weaponSelect" style="width:100%;"></select>
    <div class="small" id="weaponMeta"></div>
  </section>

  <!-- ä¸­å¤® -->
  <section class="card">
    <h2>â‘¢ å„ªå…ˆåº¦ï¼ˆ1=å¿…é ˆ / 2=ä¸‹ã’å¯ / 3=æ¶ˆã—ã¦å¯ï¼‰</h2>
    <div id="priorityPanel" class="list"></div>
    <hr class="sep" />
    <h2>â‘£ æ¤œç´¢</h2>
    <button id="run" class="btn primary">ã“ã®æ¡ä»¶ã§æ¤œç´¢ã™ã‚‹</button>
    <div style="margin-top:8px;">
      <label><input type="checkbox" id="optTryUpgrade" /> ä½™ã‚Šã‚¹ãƒ­ã§ã€ŒæŒ‡å®šã‚¹ã‚­ãƒ«+1ã€ã‚’æ¢ç´¢</label>
    </div>
  </section>

  <!-- å³ -->
  <section class="card">
    <h2>â‘¤ çµæœ</h2>
    <div id="result"></div>
    <hr class="sep" />
    <h2>â‘¥ ä¸æˆç«‹æ™‚ã®ææ¡ˆ</h2>
    <div id="fallback"></div>
  </section>
</main>

<!-- ====== æ‰€æŒè£…é£¾å“ ====== -->
<main id="view-owned" class="wrap-full" style="display:none;">
  <section class="card">
    <h2>æ‰€æŒè£…é£¾å“ã®ç®¡ç†</h2>
    <div class="grid-2" style="margin-top:8px;">
      <div>
        <label class="small muted">æ¤œç´¢ï¼ˆåç§° or ã‚¹ã‚­ãƒ«åï¼‰</label>
        <input id="ownedFilter" placeholder="ä¾‹: æ”»æ’ƒ or æ”»æ’ƒç " />
      </div>
      <div class="row" style="align-items:flex-end;">
        <button id="resetOwned" class="btn bad">å…¨ãƒªã‚»ãƒƒãƒˆï¼ˆ0ã«ï¼‰</button>
        <button id="exportOwned" class="btn">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆï¼ˆJSONï¼‰</button>
        <label class="btn">
          ã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼ˆJSON/CSVï¼‰
          <input id="importOwned" type="file" accept=".json,.csv" hidden />
        </label>
        <button id="maxOwned" class="btn ok">å…¨éƒ¨MAX</button>
      </div>
    </div>
    <div class="small" style="margin-top:6px;">åœ¨åº«ã¯ãƒ–ãƒ©ã‚¦ã‚¶ä¿å­˜ï¼ˆlocalStorageï¼‰ã€‚ã€Œæ‰€æŒè£…é£¾å“ã‚’è¨ˆç®—ã«åæ˜ ã€ã‚’ã‚ªãƒ³ã§é©ç”¨ã€‚</div>
    <hr class="sep" />
    <div id="ownedList" class="list"></div>
  </section>
</main>

<script>
/** ===================== è¨­å®š ===================== **/
const DEFAULT_SHEET_ID = "19dqfEFxbwie8HISr2QH7P1alkxErZWJiZ-8cBKHg4RI";
const SHEETS = {
  weapons: "weapons_ja",
  armor: "armor_ja",
  decos: "decorations_ja",
  skills: "skills_ja",
  series: "series_bonus_ja",
};
const PRIORITY_WEIGHT = {1:100, 2:10, 3:1};
const LS_SHEET_ID = "mhw_sheet_id";
const LS_USE_OWNED = "mhw_use_owned";
const LS_OWNED_DECOS = "mhw_owned_decos";
const DEFAULT_OWNED_MAX = 99;

const PART_ORDER = ["head","chest","arms","waist","legs"];
const PART_JA = { head:"é ­", chest:"èƒ´", arms:"è…•", waist:"è…°", legs:"è„š" };

function gsheetCsvUrl(sheetId, sheetName){
  return `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=${encodeURIComponent(sheetName)}`;
}

/** ===================== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ===================== **/
function parseSlots(text){
  if (!text) return [];
  const s = (''+text).trim();
  if (!s) return [];
  return s.split('-').map(t=>parseInt(t.trim(),10)).filter(n=>!isNaN(n));
}
function canFit(slotSize, decoSlot){
  if (slotSize >= 3) return [1,2,3].includes(decoSlot);
  if (slotSize == 2) return [1,2].includes(decoSlot);
  return decoSlot === 1;
}
function normalizePartJaToKey(v){
  const s = (v||'').toString().trim();
  const map = {
    "é ­":"head","ãƒ˜ãƒƒãƒ‰":"head","Head":"head","é ­è£…å‚™":"head","é ­é˜²å…·":"head",
    "èƒ´":"chest","ãƒœãƒ‡ã‚£":"chest","Chest":"chest","èƒ´è£…å‚™":"chest",
    "è…•":"arms","ã‚¢ãƒ¼ãƒ ":"arms","Arms":"arms",
    "è…°":"waist","ã‚¦ã‚¨ã‚¹ãƒˆ":"waist","Waist":"waist",
    "è„š":"legs","ãƒ¬ãƒƒã‚°":"legs","Legs":"legs"
  };
  return map[s] || '';
}
function inferPartFromName(name){
  const n = (name||'').toString();
  if (/(ãƒ˜ãƒ«ãƒ |ã‚­ãƒ£ãƒƒãƒ—|ã‚¯ãƒ©ã‚¦ãƒ³|ãƒ•ãƒ¼ãƒ‰|ãƒã‚¹ã‚¯|ã‚µãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆ|ãƒãƒ³ãƒ‰|ã‚¢ã‚¤|ãƒ˜ãƒƒãƒ‰)/.test(n)) return "head";
  if (/(ãƒ¡ã‚¤ãƒ«|ãƒ¬ã‚¸ã‚¹ãƒˆ|ãƒ™ã‚¹ãƒˆ|ãƒ—ãƒ¬ãƒ¼ãƒˆ|ã‚¸ãƒ£ã‚±ãƒƒãƒˆ|ã‚¹ãƒ¼ãƒ„|ãƒã‚§ã‚¹ãƒˆ|ãƒãƒƒã‚¯|ãƒœãƒ‡ã‚£|èƒ´)/.test(n)) return "chest";
  if (/(ã‚¢ãƒ¼ãƒ |ã‚°ãƒ©ãƒ–|ã‚¬ãƒ³ãƒˆãƒ¬ãƒƒãƒˆ|ãƒ´ã‚¡ãƒ³ãƒ–ãƒ¬ã‚¤ã‚¹|ã‚°ãƒ­ãƒ¼ãƒ–|ãƒ–ãƒ¬ã‚¤ã‚¹|è…•)/.test(n)) return "arms";
  if (/(ã‚³ã‚¤ãƒ«|ãƒ™ãƒ«ãƒˆ|ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰|ã‚¹ã‚«ãƒ¼ãƒˆ|è…°)/.test(n)) return "waist";
  if (/(ã‚°ãƒªãƒ¼ãƒ´|ãƒ–ãƒ¼ãƒ„|ãƒ¬ã‚¬ãƒ¼ã‚¹|ãƒ‘ãƒ³ãƒ„|ã‚½ãƒƒã‚¯ã‚¹|è„š)/.test(n)) return "legs";
  return "";
}
function val(row, candidates){
  const keys = Object.keys(row||{});
  for (const want of candidates){
    const w = (want||'').toString().trim();
    for (const k of keys){
      if ((k||'').toString().trim() === w) return row[k];
    }
  }
  return "";
}
function toInt(x, def=0){ const n = parseInt(x,10); return isNaN(n) ? def : n; }
function downloadText(filename, text){
  const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([text], {type:"text/plain"}));
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}

/** ===================== ã‚¹ã‚­ãƒ«æŠ½å‡ºï¼ˆå …ç‰¢ï¼‰ ===================== **/
function extractSkillsFromRow(row, namePrefix){
  const skills = {};
  const keys = Object.keys(row||{});
  const nameKeys = keys.filter(k => (k||'').toString().trim().startsWith(namePrefix) && !/(SL|Lv|ãƒ¬ãƒ™ãƒ«)\s*$/i.test((k||'').toString().trim()));
  for (const nk of nameKeys){
    const skName = (row[nk] || "").toString().trim();
    if (!skName) continue;
    const candLvKeys = [nk+" SL", nk+"SL", nk+"  SL", nk+" Lv", nk+"Lv", nk+" ãƒ¬ãƒ™ãƒ«"];
    let lv = 0;
    for (const lk of candLvKeys){
      const hit = val(row, [lk]);
      if (hit !== "") { lv = toInt(hit, 0); break; }
    }
    if (lv <= 0) lv = 1;
    skills[skName] = (skills[skName] || 0) + lv;
  }
  return skills;
}

/** ===================== ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ ===================== **/
async function loadCsv(url){
  const res = await fetch(url, {cache:'no-store'});
  const text = await res.text();
  return new Promise((resolve)=>{
    Papa.parse(text, { header:true, dynamicTyping:false, complete: (r)=>resolve(r.data) });
  });
}
async function loadAll(sheetId){
  const [wep, arm, dec, skl, ser] = await Promise.all([
    loadCsv(gsheetCsvUrl(sheetId, SHEETS.weapons)),
    loadCsv(gsheetCsvUrl(sheetId, SHEETS.armor)),
    loadCsv(gsheetCsvUrl(sheetId, SHEETS.decos)),
    loadCsv(gsheetCsvUrl(sheetId, SHEETS.skills)),
    loadCsv(gsheetCsvUrl(sheetId, SHEETS.series)),
  ]);
  return {wep, arm, dec, skl, ser};
}

/** ===================== ç´¢å¼•æ§‹ç¯‰ ===================== **/
function buildSkillRoster(skl){
  const out = {};
  for (const r of skl||[]){
    const name = val(r, ["ã‚¹ã‚­ãƒ«å","name","åç§°"]);
    const mx = toInt(val(r, ["æœ€å¤§Lv","æœ€å¤§ãƒ¬ãƒ™ãƒ«","maxLv","max"]), null);
    if (name) out[name] = (mx??null);
  }
  return out;
}
function buildWeaponIndex(wep){
  const idx = {};
  for (const r of wep||[]){
    const name = val(r,["æ­¦å™¨å","åç§°","name"]); if (!name) continue;
    const slots = parseSlots(val(r,["ã‚¹ãƒ­ãƒƒãƒˆ","slots"]));
    const skills = extractSkillsFromRow(r, "æ­¦å™¨ã‚¹ã‚­ãƒ«");
    idx[name] = { slots, skills };
  }
  return idx;
}
function buildArmorIndex(arm){
  const byPart = {head:[],chest:[],arms:[],waist:[],legs:[], _unknown:[]};
  for (const r of arm||[]){
    const name = val(r,["é˜²å…·å","åç§°","name"]);
    let partRaw = val(r,["éƒ¨ä½","kind","éƒ¨ä½å","éƒ¨ ä½"]);
    let part = normalizePartJaToKey(partRaw);
    if (!part) part = inferPartFromName(name);
    if (!name || !part){
      byPart._unknown.push({ name, partRaw: (partRaw||"").toString() });
      continue;
    }
    const slots = parseSlots(val(r,["ã‚¹ãƒ­ãƒƒãƒˆ","slots"]));
    const set_id = (val(r,["ã‚»ãƒƒãƒˆID","set_id","setId"]) || "").toString();
    const skills = extractSkillsFromRow(r, "ä»˜ä¸ã‚¹ã‚­ãƒ«");
    byPart[part].push({ name, slots, skills, set_id, part });
  }
  return byPart;
}
function buildDecoIndexes(dec){
  const s2d = {};
  const catalog = [];
  for (const r of dec||[]){
    const name = val(r,["è£…é£¾å“å","åç§°","name"]); const slot = toInt(val(r,["ã‚¹ãƒ­ãƒƒãƒˆ","slot","slots"]), 0);
    if (!name || !slot) continue;
    const skills = extractSkillsFromRow(r, "ä»˜ä¸ã‚¹ã‚­ãƒ«");
    for (const [sk, lv] of Object.entries(skills)){
      (s2d[sk] = s2d[sk] || []).push({ dname:name, slot, lv });
    }
    catalog.push({ name, slot, skills });
  }
  for (const sk of Object.keys(s2d)){
    s2d[sk].sort((a,b)=> (a.slot-b.slot) || (b.lv - a.lv) || a.dname.localeCompare(b.dname));
  }
  catalog.sort((a,b)=> (a.slot-b.slot) || a.name.localeCompare(b.name));
  return { s2d, catalog };
}
function buildSeriesIndex(ser){
  const mp = {};
  for (const r of ser||[]){
    const sid = (val(r,["ã‚»ãƒƒãƒˆID","set_id","setId"])||"").toString();
    const req = toInt(val(r,["å¿…è¦éƒ¨ä½æ•°","required","count"]), 0);
    const sk = val(r,["ã‚¹ã‚­ãƒ«å","name","skill"]);
    const lv = toInt(val(r,["Lv","ãƒ¬ãƒ™ãƒ«","level"]), 0);
    if (!sid || !sk || !lv) continue;
    (mp[sid] = mp[sid] || []).push({ required:req, skill:sk, lv });
  }
  return mp;
}

/** ===================== æ‰€æŒè£…é£¾å“ï¼ˆåœ¨åº«ç®¡ç†ï¼‰ ===================== **/
let DecoCatalog=[];        // [{name, slot, skills}]
let OwnedDecos = {};       // {name: count}
function loadOwnedDecos(){
  try{ return JSON.parse(localStorage.getItem(LS_OWNED_DECOS) || "{}"); }catch{ return {}; }
}
function saveOwnedDecos(map){ localStorage.setItem(LS_OWNED_DECOS, JSON.stringify(map||{})); }
function renderOwnedList(){
  const list = document.getElementById("ownedList");
  const q = (document.getElementById("ownedFilter").value||"").trim().toLowerCase();
  list.innerHTML="";
  const frag = document.createDocumentFragment();
  for (const d of DecoCatalog){
    const skillsText = Object.entries(d.skills).map(([k,v])=>`${k}+${v}`).join(", ");
    if (q){
      const hit = d.name.toLowerCase().includes(q) || skillsText.toLowerCase().includes(q);
      if (!hit) continue;
    }
    const row = document.createElement("div");
    row.className="row"; row.style.marginBottom="8px";
    const meta = document.createElement("div");
    meta.className="grow small";
    meta.innerHTML = `<span class="pill mono">${d.name}</span> <span class="pill">slot${d.slot}</span> <span class="muted">${skillsText||'-'}</span>`;
    const input = document.createElement("input");
    input.type="number"; input.min="0"; input.step="1"; input.className="qty";
    input.value = OwnedDecos[d.name]||0;
    input.onchange = ()=>{ OwnedDecos[d.name] = Math.max(0, parseInt(input.value||"0",10)||0); saveOwnedDecos(OwnedDecos); };
    const plus = document.createElement("button"); plus.className="btn"; plus.textContent="+";
    plus.onclick = ()=>{ input.value = (parseInt(input.value||"0",10)||0)+1; input.onchange(); };
    const minus = document.createElement("button"); minus.className="btn"; minus.textContent="-";
    minus.onclick = ()=>{ input.value = Math.max(0,(parseInt(input.value||"0",10)||0)-1); input.onchange(); };
    row.appendChild(meta); row.appendChild(minus); row.appendChild(plus); row.appendChild(input);
    frag.appendChild(row);
  }
  list.appendChild(frag);
}
function importOwned(file){
  const reader = new FileReader();
  reader.onload = () => {
    try{
      let map = {};
      if (file.name.endsWith(".json")){
        map = JSON.parse(reader.result);
      }else{
        const res = Papa.parse(reader.result, {header:true});
        for (const r of res.data){
          const name = r["è£…é£¾å“å"] || r["name"] || r["è£…é£¾å“"] || r["deco"] || "";
          const n = parseInt(r["æ‰€æŒæ•°"] || r["count"] || r["qty"] || "0", 10);
          if (name) map[name]=Math.max(0, n||0);
        }
      }
      OwnedDecos = map;
      saveOwnedDecos(OwnedDecos);
      renderOwnedList();
      alert("æ‰€æŒè£…é£¾å“ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸã€‚");
    }catch(e){ alert("ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ: "+e.message); }
  };
  reader.readAsText(file);
}

/** ===================== ã‚³ã‚¢è¨ˆç®— ===================== **/
const PRIORITY_WEIGHT = {1:100, 2:10, 3:1};
const skillRoster = {}; // {skillName: maxLv|null}
let WIDX={}, AIDX={}, DIDX={}, SIDX={};

function greedyPickArmor(partsIndex, targets, priority){
  const picked = [];
  for (const part of PART_ORDER){
    const cand = partsIndex[part] || [];
    let best=null, bestScore=-1;
    for (const p of cand){
      let score = 0;
      for (const sk of Object.keys(targets)){
        const need = targets[sk];
        const w = PRIORITY_WEIGHT[ priority[sk] || 1 ] || 1;
        const gain = Math.min(need, p.skills[sk] || 0);
        score += gain * w;
      }
      score += 0.01 * (p.slots.reduce((a,b)=>a+b,0));
      if (score > bestScore){ bestScore=score; best=p; }
    }
    if (best) picked.push({...best, part});
  }
  return picked;
}
function combineSkills(dicts){
  const out = {};
  for (const d of dicts){
    for (const [k,v] of Object.entries(d)) out[k]=(out[k]||0)+v;
  }
  return out;
}
function computeSeriesSkills(seriesIndex, pickedArmor){
  const cnt = {};
  for (const p of pickedArmor){
    const sid = p.set_id; if (!sid) continue;
    cnt[sid] = (cnt[sid]||0)+1;
  }
  const bonus = {};
  for (const [sid,n] of Object.entries(cnt)){
    for (const b of (seriesIndex[sid]||[])){
      if (n >= b.required) bonus[b.skill] = (bonus[b.skill]||0)+b.lv;
    }
  }
  return bonus;
}
function diffTargets(targets, have){
  const d = {};
  for (const [sk,need] of Object.entries(targets)){
    const hv = have[sk]||0;
    if (hv < need) d[sk] = need - hv;
  }
  return d;
}
function buildSlotPool(weaponName, weaponSlots, pickedArmor){
  const pool = [];
  weaponSlots.forEach((sz,i)=>{ pool.push({ size:sz, origin:"weapon", originName:(weaponName||"æ­¦å™¨"), part:"weapon", slotNo:i+1 }); });
  for (const p of pickedArmor){ p.slots.forEach((sz,i)=>{ pool.push({ size:sz, origin:"armor", originName:p.name, part:p.part, slotNo:i+1 }); }); }
  return pool;
}
function fillWithDecorationsUnlimited(slotPool, deficits, skill2decos){
  const slots = [...slotPool].sort((a,b)=>b.size-a.size);
  const assign = [];
  for (const [sk, need0] of Object.entries(deficits)){
    let need = need0;
    const cand = skill2decos[sk];
    if (!cand) return { ok:false, assign, remain:slots, used:{} };
    while (need > 0){
      let placed = false;
      for (let i=0;i<slots.length;i++){
        const s = slots[i];
        const usable = cand.filter(d=>canFit(s.size, d.slot));
        if (!usable.length) continue;
        const pick = usable[0];
        const use = Math.min(need, pick.lv);
        assign.push({ skill: sk, deco: pick.dname, slotSize: s.size, part: s.part, origin: s.originName, slotNo: s.slotNo, lv: use });
        need -= use;
        slots.splice(i,1);
        placed = true;
        break;
      }
      if (!placed) return { ok:false, assign, remain:slots, used:{} };
    }
  }
  return { ok:true, assign, remain:slots, used:{} };
}
function fillWithDecorationsOwned(slotPool, deficits, skill2decos, ownedMap){
  const slots = [...slotPool].sort((a,b)=>b.size-a.size);
  const assign = [];
  const owned = JSON.parse(JSON.stringify(ownedMap || {}));
  const used = {};
  for (const [sk, need0] of Object.entries(deficits)){
    let need = need0;
    const cand = skill2decos[sk];
    if (!cand) return { ok:false, assign, remain:slots, used };
    while (need > 0){
      let placed = false;
      for (let i=0;i<slots.length;i++){
        const s = slots[i];
        const usable = cand.filter(d=> canFit(s.size, d.slot) && (owned[d.dname]||0) > 0);
        if (!usable.length) continue;
        const pick = usable[0];
        const use = Math.min(need, pick.lv);
        assign.push({ skill: sk, deco: pick.dname, slotSize: s.size, part: s.part, origin: s.originName, slotNo: s.slotNo, lv: use });
        need -= use;
        slots.splice(i,1);
        owned[pick.dname] = (owned[pick.dname]||0) - 1;
        used[pick.dname] = (used[pick.dname]||0) + 1;
        placed = true;
        break;
      }
      if (!placed) return { ok:false, assign, remain:slots, used };
    }
  }
  return { ok:true, assign, remain:slots, used };
}

/** ===== é›†è¨ˆ/è¡¨ç¤ºï¼šåˆè¨ˆã‚¹ã‚­ãƒ«ï¼†ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ ===== **/
function reduceAssignToSkill(assign){
  const add = {};
  for (const a of assign){ add[a.skill] = (add[a.skill]||0) + a.lv; }
  return add;
}
function renderTotals(resultNode, targets, baseTotals, assignTotals){
  const finalTotals = {...baseTotals};
  for (const [k,v] of Object.entries(assignTotals)) finalTotals[k]=(finalTotals[k]||0)+v;

  // 1) ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®åˆè¨ˆã‚’è¦ç´„
  const sumBox = document.createElement("div");
  sumBox.innerHTML = `<h3>åˆè¨ˆã‚¹ã‚­ãƒ«ï¼ˆã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼‰</h3>`;
  for (const sk of Object.keys(targets)){
    const want = targets[sk];
    const have = finalTotals[sk]||0;
    const cap = skillRoster[sk] ?? null;
    const extraVsTarget = have - want;
    const overCap = (cap && have > cap) ? (have - cap) : 0;

    const line = document.createElement("div");
    line.className = "small mono";
    let txt = `- ${sk}: æœ€çµ‚Lv${have} / ç›®æ¨™Lv${want}`;
    if (cap) txt += ` / æœ€å¤§Lv${cap}`;
    if (extraVsTarget > 0) txt += `  <span class="overtarget">ï¼ˆç›®æ¨™æ¯” +${extraVsTarget} ä½™å‰°ï¼‰</span>`;
    if (overCap > 0) txt += `  <span class="overcap">â€»æœ€å¤§è¶…é +${overCap}</span>`;
    line.innerHTML = txt;
    sumBox.appendChild(line);
  }
  resultNode.appendChild(sumBox);

  // 2) å…¨ã‚¹ã‚­ãƒ«ã®åˆè¨ˆï¼ˆæŠ˜ã‚ŠãŸãŸã¿ï¼‰
  const all = Object.entries(finalTotals).filter(([,v])=>v>0).sort((a,b)=> a[0].localeCompare(b[0]));
  const details = document.createElement("details");
  details.open = false;
  details.innerHTML = `<summary class="small">å…¨ã‚¹ã‚­ãƒ«åˆè¨ˆï¼ˆã‚¯ãƒªãƒƒã‚¯ã§å±•é–‹ï¼‰</summary>`;
  const tbl = document.createElement("table");
  tbl.innerHTML = `<thead><tr>
    <th>ã‚¹ã‚­ãƒ«</th><th>æœ€çµ‚Lv</th><th>ç›®æ¨™</th><th>æœ€å¤§Lv</th><th>ä½™å‰°(ç›®æ¨™æ¯”)</th><th>æœ€å¤§è¶…é</th>
  </tr></thead><tbody></tbody>`;
  const tb = tbl.querySelector("tbody");
  for (const [sk,lv] of all){
    const want = targets[sk]||0;
    const cap = skillRoster[sk] ?? null;
    const extra = Math.max(0, lv - want);
    const over = cap ? Math.max(0, lv - cap) : 0;
    const tr = document.createElement("tr");
    tr.innerHTML = `<td>${sk}</td>
      <td class="mono">${lv}</td>
      <td class="mono">${want||'-'}</td>
      <td class="mono">${cap ?? '-'}</td>
      <td class="mono ${extra>0?'overtarget':''}">${extra>0?`+${extra}`:'-'}</td>
      <td class="mono ${over>0?'overcap':''}">${over>0?`+${over}`:'-'}</td>`;
    tb.appendChild(tr);
  }
  details.appendChild(tbl);
  resultNode.appendChild(details);

  return finalTotals;
}

/** ===================== UIçŠ¶æ…‹ ===================== **/
const $ = (q)=>document.querySelector(q);
let DecoLoaded = false;
const state = { picked:{}, priorities:{}, weapon:null };

/** ===================== åˆæœŸåŒ– ===================== **/
async function bootstrap(){
  // ã‚¿ãƒ–
  const tabSim = document.getElementById("tab-sim");
  const tabOwned = document.getElementById("tab-owned");
  const viewSim = document.getElementById("view-sim");
  const viewOwned = document.getElementById("view-owned");
  tabSim.onclick = ()=>{ tabSim.classList.add("active"); tabOwned.classList.remove("active"); viewSim.style.display="grid"; viewOwned.style.display="none"; };
  tabOwned.onclick = ()=>{ tabOwned.classList.add("active"); tabSim.classList.remove("active"); viewSim.style.display="none"; viewOwned.style.display="block"; };

  // ã‚·ãƒ¼ãƒˆID
  const sheetIdInput = $("#sheetId");
  sheetIdInput.value = localStorage.getItem(LS_SHEET_ID) || DEFAULT_SHEET_ID;
  $("#reload").onclick = async ()=>{
    localStorage.setItem(LS_SHEET_ID, sheetIdInput.value.trim());
    await loadAndIndex(sheetIdInput.value.trim());
  };

  // æ‰€æŒè£…é£¾å“ãƒˆã‚°ãƒ«
  const useOwned = $("#useOwned");
  useOwned.checked = localStorage.getItem(LS_USE_OWNED) === "1";
  useOwned.onchange = ()=> localStorage.setItem(LS_USE_OWNED, useOwned.checked ? "1" : "0");

  // æ‰€æŒè£…é£¾å“UI
  $("#ownedFilter").oninput = ()=> renderOwnedList();
  $("#resetOwned").onclick = ()=>{ if (confirm("æ‰€æŒæ•°ã‚’å…¨ã¦0ã«ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ")) { OwnedDecos = {}; saveOwnedDecos(OwnedDecos); renderOwnedList(); } };
  $("#exportOwned").onclick = ()=> downloadText("owned_decorations.json", JSON.stringify(OwnedDecos, null, 2));
  $("#importOwned").onchange = (e)=>{ const f=e.target.files?.[0]; if (f) importOwned(f); e.target.value=""; };
  document.getElementById("maxOwned").onclick = ()=>{
    if (!confirm("å…¨è£…é£¾å“ã®æ‰€æŒæ•°ã‚’MAXã«ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ")) return;
    for (const d of DecoCatalog) OwnedDecos[d.name] = DEFAULT_OWNED_MAX;
    saveOwnedDecos(OwnedDecos);
    renderOwnedList();
  };

  // ã‚¹ã‚­ãƒ«è¿½åŠ 
  $("#addSkill").onclick = ()=>{
    const name = $("#skillPicker").value.trim();
    if (!name || !(name in skillRoster)) return;
    if (!state.picked[name]) state.picked[name] = { target: Math.min(3, skillRoster[name]||3), max: (skillRoster[name]||null) };
    if (!state.priorities[name]) state.priorities[name]=1;
    $("#skillPicker").value="";
    renderPicked(); renderPriorityPanel();
  };

  // æ­¦å™¨é¸æŠ
  $("#weaponSelect").onchange = ()=>{
    const val = $("#weaponSelect").value;
    state.weapon = val || null;
    const meta = $("#weaponMeta"); meta.innerHTML="";
    if (state.weapon){
      const w = WIDX[state.weapon];
      meta.innerHTML = `<div class="small">ã‚¹ãƒ­ãƒƒãƒˆ: <span class="mono">${w.slots.join("-")||"-"}</span> ï¼ æ­¦å™¨ã‚¹ã‚­ãƒ«: ${Object.keys(w.skills).length? JSON.stringify(w.skills):"ãªã—"}</div>`;
    }
  };

  // å®Ÿè¡Œ
  $("#run").onclick = ()=> runSearch();

  // æ‰€æŒãƒ‡ãƒ¼ã‚¿
  OwnedDecos = loadOwnedDecos();

  // åˆå›ãƒ­ãƒ¼ãƒ‰
  await loadAndIndex(sheetIdInput.value.trim());
}

async function loadAndIndex(sheetId){
  const out = $("#result"); out.textContent="èª­ã¿è¾¼ã¿ä¸­...";
  const fb = $("#fallback"); fb.textContent="";
  try{
    const {wep, arm, dec, skl, ser} = await loadAll(sheetId);
    Object.assign(skillRoster, buildSkillRoster(skl));
    WIDX = buildWeaponIndex(wep);
    AIDX = buildArmorIndex(arm);
    const d = buildDecoIndexes(dec);
    DIDX = d.s2d; DecoCatalog = d.catalog;
    SIDX = buildSeriesIndex(ser);

    if (!localStorage.getItem(LS_OWNED_DECOS)) {
      OwnedDecos = {};
      for (const deco of DecoCatalog) OwnedDecos[deco.name] = DEFAULT_OWNED_MAX;
      saveOwnedDecos(OwnedDecos);
    }

    renderSkillPicker();
    renderWeapons();
    renderOwnedList();

    const cnt = {
      head: AIDX.head.length, chest: AIDX.chest.length, arms: AIDX.arms.length,
      waist: AIDX.waist.length, legs: AIDX.legs.length, unknown: AIDX._unknown.length
    };
    out.innerHTML =
      `ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å®Œäº†ã€‚æ¡ä»¶ã‚’æŒ‡å®šã—ã¦æ¤œç´¢ã—ã¦ãã ã•ã„ã€‚<br>` +
      `<span class="small muted">é˜²å…·: é ­${cnt.head} èƒ´${cnt.chest} è…•${cnt.arms} è…°${cnt.waist} è„š${cnt.legs}ï¼ˆæœªåˆ†é¡:${cnt.unknown}ï¼‰ ï¼ `+
      `æ­¦å™¨: ${Object.keys(WIDX).length} ï¼ è£…é£¾å“: ${DecoCatalog.length}</span>`;

    if (AIDX._unknown.length){
      const warn = document.createElement("div");
      warn.className="small";
      const samples = AIDX._unknown.slice(0,5).map(u=>`[${u.partRaw||"??"}]${u.name||"(åç§°ãªã—)"}`).join(", ");
      warn.innerHTML = `æœªåˆ†é¡ã®é˜²å…·ãŒ <b>${AIDX._unknown.length}</b> ä»¶ã‚ã‚Šã¾ã™ï¼ˆéƒ¨ä½åˆ—ã®è¡¨è¨˜ã‚†ã‚Œï¼‰ã€‚ä¾‹: ${samples}`;
      out.appendChild(warn);
    }
  }catch(e){
    out.innerHTML = `<span class="error">ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã§ã‚¨ãƒ©ãƒ¼: ${e?.message||e}</span>`;
  }
}

/** ===================== æç”» ===================== **/
function renderSkillPicker(){
  const dl = $("#skillList");
  dl.innerHTML = "";
  Object.keys(skillRoster).sort().forEach(n=>{
    const opt = document.createElement("option"); opt.value = n; dl.appendChild(opt);
  });
}
function renderWeapons(){
  const sel = $("#weaponSelect"); sel.innerHTML="";
  const none = document.createElement("option"); none.value=""; none.textContent="ï¼ˆæœªé¸æŠï¼‰";
  sel.appendChild(none);
  Object.keys(WIDX).sort().forEach(n=>{
    const op = document.createElement("option"); op.value=n; op.textContent=n; sel.appendChild(op);
  });
}
function renderPicked(){
  const box = $("#pickedSkills"); box.innerHTML="";
  Object.entries(state.picked).forEach(([sk,info])=>{
    const wrap = document.createElement("div");
    wrap.className="row"; wrap.style.alignItems="center";
    const label = document.createElement("div");
    label.className="pill"; label.innerHTML = `<span>${sk}</span><span class="muted">max:${info.max??"?"}</span>`;
    const input = document.createElement("input");
    input.type="range"; input.min="1"; input.max=(info.max||10); input.value=info.target; input.className="grow";
    input.oninput=()=>{ state.picked[sk].target = parseInt(input.value,10); renderPriorityPanel(); };
    const num = document.createElement("span"); num.className="pill"; num.textContent = `Lv${info.target}`;
    input.addEventListener("input", ()=> num.textContent = `Lv${input.value}`);
    const del = document.createElement("button"); del.className="btn bad"; del.textContent="å‰Šé™¤";
    del.onclick=()=>{ delete state.picked[sk]; delete state.priorities[sk]; renderPicked(); renderPriorityPanel(); };
    wrap.appendChild(label); wrap.appendChild(input); wrap.appendChild(num); wrap.appendChild(del);
    box.appendChild(wrap);
  });
}
function renderPriorityPanel(){
  const box = $("#priorityPanel"); box.innerHTML="";
  Object.keys(state.picked).forEach(sk=>{
    const row = document.createElement("div"); row.className="row";
    const lbl = document.createElement("div"); lbl.className="pill"; lbl.textContent=sk;
    const sel = document.createElement("select");
    [1,2,3].forEach(v=>{
      const op = document.createElement("option"); op.value=v; op.textContent=v;
      if ((state.priorities[sk]||1)===v) op.selected=true;
      sel.appendChild(op);
    });
    sel.onchange=()=>{ state.priorities[sk]=parseInt(sel.value,10); };
    row.appendChild(lbl); row.appendChild(sel);
    box.appendChild(row);
  });
}

/** ===================== å®Ÿè¡Œ ===================== **/
function runSearch(){
  const res = $("#result"); const fb = $("#fallback"); res.innerHTML=""; fb.innerHTML="";
  const targets = {}; const prio = {};
  Object.entries(state.picked).forEach(([sk,info])=> targets[sk]=info.target);
  Object.entries(state.priorities).forEach(([sk,v])=> prio[sk]=v);

  const weaponSlots = state.weapon ? WIDX[state.weapon].slots : [];
  const weaponSkills = state.weapon ? WIDX[state.weapon].skills : {};

  // 5éƒ¨ä½é¸æŠ
  const picked = greedyPickArmor(AIDX, targets, prio);

  // è£…å‚™å†…è¨³ãƒ†ãƒ¼ãƒ–ãƒ«
  const tbl = document.createElement("table");
  tbl.innerHTML = `<thead><tr>
    <th style="width:80px;">éƒ¨ä½</th><th>è£…å‚™å</th><th style="width:110px;">ã‚¹ãƒ­ãƒƒãƒˆ</th><th>å¯¾è±¡ã‚¹ã‚­ãƒ«å¯„ä¸</th>
  </tr></thead><tbody></tbody>`;
  const tbody = tbl.querySelector("tbody");
  for (const part of PART_ORDER){
    const row = document.createElement("tr");
    const pick = picked.find(x=>x.part===part);
    if (pick){
      const contrib = Object.keys(targets)
        .filter(sk=> (pick.skills[sk]||0) > 0)
        .map(sk=> `<span class="tag">${sk}+${pick.skills[sk]}</span>`).join(" ");
      row.innerHTML = `<td>${PART_JA[part]}</td>
        <td>${pick.name}</td>
        <td class="mono">${pick.slots.join('-')||'-'}</td>
        <td>${contrib || '<span class="muted">-</span>'}</td>`;
    }else{
      row.innerHTML = `<td>${PART_JA[part]}</td><td class="muted">ï¼ˆæœªé¸ï¼‰</td><td>-</td><td>-</td>`;
    }
    tbody.appendChild(row);
  }
  // æ­¦å™¨è¡Œ
  const wrow = document.createElement("tr");
  wrow.innerHTML = `<td>æ­¦å™¨</td>
    <td>${state.weapon || '<span class="muted">ï¼ˆæœªé¸ï¼‰</span>'}</td>
    <td class="mono">${weaponSlots.join('-')||'-'}</td>
    <td>${
      Object.keys(weaponSkills).length
        ? Object.entries(weaponSkills).map(([k,v])=>`<span class="tag">${k}+${v}</span>`).join(" ")
        : '<span class="muted">-</span>'
    }</td>`;
  tbody.appendChild(wrow);
  res.appendChild(tbl);

  // åˆç®—ï¼ˆç´ ã‚¹ã‚­ãƒ«+ã‚·ãƒªãƒ¼ã‚ºï¼‰
  const baseTotals = combineSkills([weaponSkills, ...picked.map(p=>p.skills)]);
  const series = computeSeriesSkills(SIDX, picked);
  for (const [k,v] of Object.entries(series)) baseTotals[k]=(baseTotals[k]||0)+v;

  // ã‚¹ãƒ­ãƒƒãƒˆãƒ—ãƒ¼ãƒ«
  const slotPool = buildSlotPool(state.weapon, weaponSlots, picked);

  // å·®åˆ†
  const deficits = diffTargets(targets, baseTotals);

  // è£…é£¾å“ã§å……è¶³
  const useOwned = document.getElementById("useOwned").checked;
  const filled = useOwned
    ? fillWithDecorationsOwned(slotPool, deficits, DIDX, OwnedDecos)
    : fillWithDecorationsUnlimited(slotPool, deficits, DIDX);

  // ã‚·ãƒªãƒ¼ã‚ºç™ºå‹•è¡¨ç¤º
  if (Object.keys(series).length){
    const d = document.createElement("div");
    d.className="small"; d.textContent = `ã‚·ãƒªãƒ¼ã‚ºç™ºå‹•: ${JSON.stringify(series)}`;
    res.appendChild(d);
  }
  if (useOwned){
    const d = document.createElement("div");
    d.className="small muted"; d.textContent = "â€» æ‰€æŒè£…é£¾å“åˆ¶é™ã‚’åæ˜ ä¸­";
    res.appendChild(d);
  }

  if (picked.length===0){
    const warn = document.createElement("div");
    warn.className="small error";
    warn.textContent = "é˜²å…·å€™è£œãŒ0ä»¶ã§ã™ã€‚armor_jaã®ã€Œéƒ¨ä½/ã‚¹ãƒ­ãƒƒãƒˆ/ä»˜ä¸ã‚¹ã‚­ãƒ«ã€åˆ—åã‚„å€¤ã®è¡¨è¨˜ã‚†ã‚ŒãŒåŸå› ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚";
    res.appendChild(warn);
  }

  if (filled.ok){
    const ok = document.createElement("div");
    ok.className="success"; ok.textContent="ğŸ‰ ç›®æ¨™ã‚¹ã‚­ãƒ«ã‚’æº€ãŸã›ã¾ã—ãŸ";
    res.appendChild(ok);

    // è£…é£¾å“ã‚¢ã‚µã‚¤ãƒ³ï¼ˆå‡ºæ‰€ã¾ã§ï¼‰
    const assignDiv = document.createElement("div");
    assignDiv.innerHTML = `<div class="muted">è£…é£¾å“ã‚¢ã‚µã‚¤ãƒ³ï¼ˆskill / deco / éƒ¨ä½ãƒ»è£…å‚™å / slotã‚µã‚¤ã‚º / +lvï¼‰</div>`;
    for (const a of filled.assign){
      const line = document.createElement("div"); line.className="small mono";
      const partLabel = a.part==="weapon" ? "æ­¦å™¨" : (PART_JA[a.part] || a.part);
      line.textContent = `- ${a.skill} / ${a.deco} / ${partLabel}:${a.origin} / slot${a.slotSize} / +${a.lv}`;
      assignDiv.appendChild(line);
    }
    res.appendChild(assignDiv);

    if (useOwned && Object.keys(filled.used||{}).length){
      const u = document.createElement("div");
      u.innerHTML = `<div class="muted">ä»Šå›æ¶ˆè²»ã—ãŸæ‰€æŒè£…é£¾å“</div>`;
      for (const [nm,c] of Object.entries(filled.used)){
        const d = document.createElement("div"); d.className="small mono";
        d.textContent = `- ${nm}: ${c}å€‹`;
        u.appendChild(d);
      }
      res.appendChild(u);
    }

    // åˆè¨ˆï¼†ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼è¡¨ç¤ºï¼ˆæˆåŠŸæ™‚ï¼‰
    const assignTotals = reduceAssignToSkill(filled.assign);
    renderTotals(res, targets, baseTotals, assignTotals);

    // è¿½åŠ ç››ã‚Šæ¢ç´¢
    if (document.getElementById("optTryUpgrade").checked){
      const remain = filled.remain;
      const upDiv = document.createElement("div");
      upDiv.innerHTML = `<div class="muted">è¿½åŠ ã§ç››ã‚Œã‚‹ã‹æ¢ç´¢</div>`;
      let found = false;
      for (const sk of Object.keys(targets)){
        const cur = (baseTotals[sk]||0) + (assignTotals[sk]||0);
        const mx  = (skillRoster[sk] || 10);
        if (cur < mx){
          const tryAdd = useOwned
            ? fillWithDecorationsOwned(remain, {[sk]:1}, DIDX, OwnedDecos)
            : fillWithDecorationsUnlimited(remain, {[sk]:1}, DIDX);
          if (tryAdd.ok && tryAdd.assign.length){
            found = true;
            const a = tryAdd.assign[0];
            const partLabel = a.part==="weapon" ? "æ­¦å™¨" : (PART_JA[a.part] || a.part);
            const d = document.createElement("div"); d.className="small mono";
            d.textContent = `- ${sk} / ${a.deco} / ${partLabel}:${a.origin} / slot${a.slotSize} / +${a.lv}`;
            upDiv.appendChild(d);
          }
        }
      }
      if (!found){
        const nd = document.createElement("div"); nd.className="small muted"; nd.textContent="è¿½åŠ å€™è£œã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚";
        upDiv.appendChild(nd);
      }
      res.appendChild(upDiv);
    }

  }else{
    const bad = document.createElement("div");
    bad.className="error"; bad.textContent="ç›®æ¨™ã‚¹ã‚­ãƒ«ã‚’æº€ãŸã›ã¾ã›ã‚“ã§ã—ãŸã€‚";
    res.appendChild(bad);

    const def = document.createElement("div");
    def.className="small mono";
    def.textContent = "ä¸è¶³: " + JSON.stringify(deficits);
    res.appendChild(def);

    if (useOwned && Object.keys(filled.used||{}).length){
      const u = document.createElement("div");
      u.innerHTML = `<div class="muted">ä»Šå›æ¶ˆè²»ã§ããŸæ‰€æŒè£…é£¾å“ï¼ˆä¸è¶³ã®ãŸã‚æœªé”ï¼‰</div>`;
      for (const [nm,c] of Object.entries(filled.used)){
        const d = document.createElement("div"); d.className="small mono";
        d.textContent = `- ${nm}: ${c}å€‹ä½¿ç”¨`;
        u.appendChild(d);
      }
      res.appendChild(u);
    }

    // åˆè¨ˆï¼†ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼è¡¨ç¤ºï¼ˆæœªé”ã§ã‚‚ç¾çŠ¶ã‚’è¡¨ç¤ºï¼‰
    const assignTotals = reduceAssignToSkill(filled.assign);
    renderTotals(res, targets, baseTotals, assignTotals);

    // å¦¥å”ææ¡ˆ
    const lowable = Object.entries(prio).filter(([sk,p])=> p>=2 && deficits[sk]).map(([sk])=>sk);
    const w = document.createElement("div");
    w.innerHTML = `<div class="muted">â‘¥-1 ææ¡ˆï¼šå„ªå…ˆåº¦2/3ã®ã‚¹ã‚­ãƒ«ã‚’ä¸‹ã’ã‚‹ã¨æˆç«‹ã™ã‚‹å¯èƒ½æ€§ã‚ã‚Š</div>
                   <div class="small mono">ä¸‹ã’å€™è£œ: ${lowable.length? lowable.join(", ") : "è©²å½“ãªã—"}</div>`;
    fb.appendChild(w);

    const t = document.createElement("div");
    t.className="small muted";
    t.textContent = "â‘¥-2 é‘‘å®šè­·çŸ³ææ¡ˆï¼šã‚·ãƒ¼ãƒˆãŒç”¨æ„ã•ã‚Œã¦ã„ã‚Œã°æ‹¡å¼µå¯èƒ½ï¼ˆæœ¬MVPã¯çœç•¥ï¼‰";
    fb.appendChild(t);
  }
}

/** ===================== èµ·å‹• ===================== **/
function initialUI(){
  const dl = $("#skillList"); dl.innerHTML="";
  $("#weaponSelect").innerHTML = `<option value="">ï¼ˆæœªé¸æŠï¼‰</option>`;
}
initialUI();
bootstrap();
</script>
</body>
</html>
