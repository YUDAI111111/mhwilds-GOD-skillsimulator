<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MHWilds 装備シミュ（Web/CSV直読＋所持装飾品）</title>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<style>
  :root { --bg:#0b0f14; --fg:#e6edf3; --muted:#9aa4ad; --accent:#5ac8fa; --ok:#22c55e; --bad:#ef4444; --card:#111720; }
  html,body { margin:0; padding:0; background:var(--bg); color:var(--fg); font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP"; }
  header { padding:16px 20px; border-bottom:1px solid #1e2631; position:sticky; top:0; background:linear-gradient(180deg,var(--bg),rgba(11,15,20,.92)); backdrop-filter: blur(6px); z-index:2; }
  header h1 { margin:0; font-size:18px; }
  .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .grow { flex:1; }
  .muted { color:var(--muted); }
  .pill { display:inline-flex; align-items:center; gap:6px; background:#111b28; border:1px solid #233047; border-radius:999px; padding:4px 9px; font-size:12px; margin:0 8px 0 0; }
  input, select, button { background:#0e141c; color:var(--fg); border:1px solid #273142; border-radius:10px; padding:9px 10px; }
  input:focus, select:focus, button:focus { outline:1px solid var(--accent); }
  .btn { cursor:pointer; background:#142033; border:1px solid #223048; }
  .btn.primary { background:#13324b; border-color:#1d4566; }
  .btn.bad { background:#3b1116; border-color:#5e1c24; }
  .btn.ok  { background:#0f2e22; border-color:#175a46; }
  nav.tabs { display:flex; gap:8px; margin-top:10px; }
  nav.tabs button { padding:8px 12px; border-radius:10px; background:#101826; border:1px solid #223047; cursor:pointer; }
  nav.tabs button.active { background:#1a2740; border-color:#2c4470; }
  .wrap { display:grid; grid-template-columns: 1fr 1.1fr 1.2fr; gap:16px; padding:16px; }
  .wrap-full { padding:16px; }
  .card { background:var(--card); border:1px solid #1e2631; border-radius:14px; padding:14px; }
  h2 { margin:0 0 10px; font-size:16px; }
  .list { max-height: 300px; overflow:auto; padding-right:6px; }
  .small { font-size:12px; color:var(--muted); }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
  .success { color: var(--ok); font-weight:600; }
  .error { color: var(--bad); font-weight:600; }
  hr.sep { border:0; border-top:1px solid #223047; margin:12px 0; }
  .grid-2 { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
  .qty { width:80px; text-align:right; }
  @media (max-width: 1100px) { .wrap { grid-template-columns: 1fr; } }
</style>
</head>
<body>

<header>
  <div class="row">
    <div>
      <h1>MHWilds 装備シミュ（Web/CSV直読）</h1>
      <div class="row" style="margin-top:8px;">
        <input id="sheetId" class="grow" placeholder="Google Sheet ID" />
        <button id="reload" class="btn">読込/更新</button>
        <span class="muted">例: 19dqfEFxbwie8HISr2QH7P1alkxErZWJiZ-8cBKHg4RI</span>
      </div>
      <nav class="tabs">
        <button id="tab-sim" class="active">シミュレーター</button>
        <button id="tab-owned">所持装飾品</button>
      </nav>
    </div>
    <div class="grow"></div>
    <div>
      <label class="row">
        <input type="checkbox" id="useOwned" />
        <span>所持装飾品を計算に反映</span>
      </label>
      <div class="small muted">オンにすると、割り当て可能な装飾品は所持数の範囲内になります。</div>
    </div>
  </div>
</header>

<!-- ====== シミュレーター ====== -->
<main id="view-sim" class="wrap">
  <!-- 左 -->
  <section class="card">
    <h2>① 欲しいスキルを選択</h2>
    <div class="row">
      <input list="skillList" id="skillPicker" placeholder="スキル名で検索" class="grow" />
      <datalist id="skillList"></datalist>
      <button id="addSkill" class="btn">追加</button>
    </div>
    <div id="pickedSkills" style="margin-top:8px;"></div>
    <hr class="sep" />
    <h2>② 武器を指定</h2>
    <select id="weaponSelect" style="width:100%;"></select>
    <div class="small" id="weaponMeta"></div>
  </section>

  <!-- 中央 -->
  <section class="card">
    <h2>③ 優先度（1=必須 / 2=下げ可 / 3=消しても可）</h2>
    <div id="priorityPanel" class="list"></div>
    <hr class="sep" />
    <h2>④ 検索</h2>
    <button id="run" class="btn primary">この条件で検索する</button>
    <div style="margin-top:8px;">
      <label><input type="checkbox" id="optTryUpgrade" /> 余りスロットで「指定スキルのLv+1」を探索</label>
    </div>
  </section>

  <!-- 右 -->
  <section class="card">
    <h2>⑤ 結果</h2>
    <div id="result"></div>
    <hr class="sep" />
    <h2>⑥ 不成立時の提案</h2>
    <div id="fallback"></div>
  </section>
</main>

<!-- ====== 所持装飾品 ====== -->
<main id="view-owned" class="wrap-full" style="display:none;">
  <section class="card">
    <h2>所持装飾品の管理</h2>
    <div class="grid-2" style="margin-top:8px;">
      <div>
        <label class="small muted">検索（名称 or スキル名）</label>
        <input id="ownedFilter" placeholder="例: 攻撃 or 攻撃珠" />
      </div>
      <div class="row" style="align-items:flex-end;">
        <button id="resetOwned" class="btn bad">全リセット（0に）</button>
        <button id="exportOwned" class="btn">エクスポート（JSON）</button>
        <label class="btn">
          インポート（JSON/CSV）
          <input id="importOwned" type="file" accept=".json,.csv" hidden />
        </label>
        <button id="maxOwned" class="btn ok">全部MAX</button>
      </div>
    </div>
    <div class="small" style="margin-top:6px;">※ 所持数はブラウザに保存（localStorage）。「所持装飾品を計算に反映」をオンで制限が効きます。</div>
    <hr class="sep" />
    <div id="ownedList" class="list"></div>
  </section>
</main>

<script>
/** ===================== 設定 ===================== **/
const DEFAULT_SHEET_ID = "19dqfEFxbwie8HISr2QH7P1alkxErZWJiZ-8cBKHg4RI";
const SHEETS = {
  weapons: "weapons_ja",
  armor: "armor_ja",
  decos: "decorations_ja",
  skills: "skills_ja",
  series: "series_bonus_ja",
};
const PRIORITY_WEIGHT = {1:100, 2:10, 3:1};
const LS_SHEET_ID = "mhw_sheet_id";
const LS_USE_OWNED = "mhw_use_owned";
const LS_OWNED_DECOS = "mhw_owned_decos";
const DEFAULT_OWNED_MAX = 99; // 全部MAXの基準値

function gsheetCsvUrl(sheetId, sheetName){
  return `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=${encodeURIComponent(sheetName)}`;
}

/** ===================== ユーティリティ ===================== **/
function parseSlots(text){
  if (!text || typeof text !== 'string') return [];
  return text.split('-').map(s=>parseInt(s.trim(),10)).filter(n=>!isNaN(n));
}
function canFit(slotSize, decoSlot){ // L3:1-3, L2:1-2, L1:1
  if (slotSize >= 3) return [1,2,3].includes(decoSlot);
  if (slotSize == 2) return [1,2].includes(decoSlot);
  return decoSlot === 1;
}
function normalizePartJaToKey(v){
  const s = (v||'').toString().trim();
  const map = {
    "頭":"head","ヘッド":"head","Head":"head","頭装備":"head","頭防具":"head",
    "胴":"chest","ボディ":"chest","Chest":"chest","胴装備":"chest",
    "腕":"arms","アーム":"arms","Arms":"arms",
    "腰":"waist","ウエスト":"waist","Waist":"waist",
    "脚":"legs","レッグ":"legs","Legs":"legs"
  };
  return map[s] || '';
}
function toInt(x, def=0){ const n = parseInt(x,10); return isNaN(n) ? def : n; }
function downloadText(filename, text){
  const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([text], {type:"text/plain"}));
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}

/** ===================== スキル抽出（堅牢） ===================== **/
// 付与スキル1 / 付与スキル1 SL, Lv, レベル などの表記ゆれを吸収
function extractSkillsFromRow(row, namePrefix){
  const skills = {};
  const keys = Object.keys(row);
  const nameKeys = keys.filter(k => k.startsWith(namePrefix) && !/(SL|Lv|レベル)\s*$/i.test(k.trim()));
  for (const nk of nameKeys){
    const skName = (row[nk] || "").toString().trim();
    if (!skName) continue;
    const candLvKeys = [nk+" SL", nk+"SL", nk+"  SL", nk+" Lv", nk+"Lv", nk+" レベル"];
    let lv = 0;
    for (const lk of candLvKeys){
      if (lk in row) { lv = toInt(row[lk], 0); break; }
    }
    if (lv <= 0) lv = 1; // 最低1でフォールバック（Lv列欠落対策）
    skills[skName] = (skills[skName] || 0) + lv;
  }
  return skills;
}

/** ===================== データ読み込み ===================== **/
async function loadCsv(url){
  const res = await fetch(url, {cache:'no-store'});
  const text = await res.text();
  return new Promise((resolve)=>{
    Papa.parse(text, { header:true, dynamicTyping:false, complete: (r)=>resolve(r.data) });
  });
}
async function loadAll(sheetId){
  const [wep, arm, dec, skl, ser] = await Promise.all([
    loadCsv(gsheetCsvUrl(sheetId, SHEETS.weapons)),
    loadCsv(gsheetCsvUrl(sheetId, SHEETS.armor)),
    loadCsv(gsheetCsvUrl(sheetId, SHEETS.decos)),
    loadCsv(gsheetCsvUrl(sheetId, SHEETS.skills)),
    loadCsv(gsheetCsvUrl(sheetId, SHEETS.series)),
  ]);
  return {wep, arm, dec, skl, ser};
}

/** ===================== 索引構築 ===================== **/
function buildSkillRoster(skl){
  const out = {};
  for (const r of skl){
    const name = r["スキル名"];
    const mx = toInt(r["最大Lv"], null);
    if (name) out[name] = mx ?? null;
  }
  return out;
}
function buildWeaponIndex(wep){
  const idx = {};
  for (const r of wep){
    const name = r["武器名"]; if (!name) continue;
    const slots = parseSlots(r["スロット"]);
    const skills = extractSkillsFromRow(r, "武器スキル");
    idx[name] = { slots, skills };
  }
  return idx;
}
function buildArmorIndex(arm){
  const byPart = {head:[],chest:[],arms:[],waist:[],legs:[]};
  for (const r of arm){
    const name = r["防具名"]; const part = normalizePartJaToKey(r["部位"]);
    if (!name || !part) continue;
    const slots = parseSlots(r["スロット"]);
    const set_id = (r["セットID"] || "").toString();
    const skills = extractSkillsFromRow(r, "付与スキル");
    byPart[part].push({ name, slots, skills, set_id });
  }
  return byPart;
}
function buildDecoIndexes(dec){
  const s2d = {};
  const catalog = [];
  for (const r of dec){
    const name = r["装飾品名"]; const slot = toInt(r["スロット"], 0);
    if (!name || !slot) continue;
    const skills = extractSkillsFromRow(r, "付与スキル");
    for (const [sk, lv] of Object.entries(skills)){
      s2d[sk] = s2d[sk] || [];
      s2d[sk].push({ dname:name, slot, lv });
    }
    catalog.push({ name, slot, skills });
  }
  for (const sk of Object.keys(s2d)){
    s2d[sk].sort((a,b)=> (a.slot-b.slot) || (b.lv - a.lv) || a.dname.localeCompare(b.dname));
  }
  catalog.sort((a,b)=> (a.slot-b.slot) || a.name.localeCompare(b.name));
  return { s2d, catalog };
}
function buildSeriesIndex(ser){
  const mp = {};
  for (const r of ser){
    const sid = r["セットID"]; const req = toInt(r["必要部位数"], 0); const sk = r["スキル名"]; const lv = toInt(r["Lv"], 0);
    if (!sid || !sk || !lv) continue;
    mp[sid] = mp[sid] || [];
    mp[sid].push({ required:req, skill:sk, lv });
  }
  return mp;
}

/** ===================== 所持装飾品（在庫管理） ===================== **/
function loadOwnedDecos(){
  try{ return JSON.parse(localStorage.getItem(LS_OWNED_DECOS) || "{}"); }catch{ return {}; }
}
function saveOwnedDecos(map){ localStorage.setItem(LS_OWNED_DECOS, JSON.stringify(map||{})); }
function renderOwnedList(){
  const list = document.getElementById("ownedList");
  const q = (document.getElementById("ownedFilter").value||"").trim().toLowerCase();
  list.innerHTML="";
  const frag = document.createDocumentFragment();
  for (const d of DecoCatalog){
    const skillsText = Object.entries(d.skills).map(([k,v])=>`${k}+${v}`).join(", ");
    if (q){
      const hit = d.name.toLowerCase().includes(q) || skillsText.toLowerCase().includes(q);
      if (!hit) continue;
    }
    const row = document.createElement("div");
    row.className="row";
    row.style.marginBottom="8px";
    const meta = document.createElement("div");
    meta.className="grow small";
    meta.innerHTML = `<span class="pill mono">${d.name}</span> <span class="pill">slot${d.slot}</span> <span class="muted">${skillsText||'-'}</span>`;
    const input = document.createElement("input");
    input.type="number"; input.min="0"; input.step="1"; input.className="qty";
    input.value = OwnedDecos[d.name]||0;
    input.onchange = ()=>{ OwnedDecos[d.name] = Math.max(0, parseInt(input.value||"0",10)||0); saveOwnedDecos(OwnedDecos); };
    const plus = document.createElement("button"); plus.className="btn"; plus.textContent="+";
    plus.onclick = ()=>{ input.value = (parseInt(input.value||"0",10)||0)+1; input.onchange(); };
    const minus = document.createElement("button"); minus.className="btn"; minus.textContent="-";
    minus.onclick = ()=>{ input.value = Math.max(0,(parseInt(input.value||"0",10)||0)-1); input.onchange(); };
    row.appendChild(meta); row.appendChild(minus); row.appendChild(plus); row.appendChild(input);
    frag.appendChild(row);
  }
  list.appendChild(frag);
}
function importOwned(file){
  const reader = new FileReader();
  reader.onload = () => {
    try{
      let map = {};
      if (file.name.endsWith(".json")){
        map = JSON.parse(reader.result);
      }else{
        const res = Papa.parse(reader.result, {header:true});
        for (const r of res.data){
          const name = r["装飾品名"] || r["name"] || r["装飾品"] || r["deco"] || "";
          const n = parseInt(r["所持数"] || r["count"] || r["qty"] || "0", 10);
          if (name) map[name]=Math.max(0, n||0);
        }
      }
      OwnedDecos = map;
      saveOwnedDecos(OwnedDecos);
      renderOwnedList();
      alert("所持装飾品をインポートしました。");
    }catch(e){ alert("インポートに失敗しました: "+e.message); }
  };
  reader.readAsText(file);
}

/** ===================== コア計算 ===================== **/
function greedyPickArmor(partsIndex, targets, priority){
  const order = ["head","chest","arms","waist","legs"];
  const picked = [];
  for (const part of order){
    const cand = partsIndex[part] || [];
    let best=null, bestScore=-1;
    for (const p of cand){
      let score = 0;
      for (const sk of Object.keys(targets)){
        const need = targets[sk];
        const w = PRIORITY_WEIGHT[ priority[sk] || 1 ] || 1;
        const gain = Math.min(need, p.skills[sk] || 0);
        score += gain * w;
      }
      score += 0.01 * (p.slots.reduce((a,b)=>a+b,0));
      if (score > bestScore){ bestScore=score; best=p; }
    }
    if (best) picked.push(best);
  }
  return picked;
}
function combineSkills(dicts){
  const out = {};
  for (const d of dicts){
    for (const [k,v] of Object.entries(d)) out[k]=(out[k]||0)+v;
  }
  return out;
}
function computeSeriesSkills(seriesIndex, pickedArmor){
  const cnt = {};
  for (const p of pickedArmor){
    const sid = p.set_id; if (!sid) continue;
    cnt[sid] = (cnt[sid]||0)+1;
  }
  const bonus = {};
  for (const [sid,n] of Object.entries(cnt)){
    for (const b of (seriesIndex[sid]||[])){
      if (n >= b.required) bonus[b.skill] = (bonus[b.skill]||0)+b.lv;
    }
  }
  return bonus;
}
function diffTargets(targets, have){
  const d = {};
  for (const [sk,need] of Object.entries(targets)){
    const hv = have[sk]||0;
    if (hv < need) d[sk] = need - hv;
  }
  return d;
}

// 無制限
function fillWithDecorationsUnlimited(slotPool, deficits, skill2decos){
  const slots = [...slotPool].sort((a,b)=>b-a);
  const assign = [];
  for (const [sk, need0] of Object.entries(deficits)){
    let need = need0;
    const cand = skill2decos[sk];
    if (!cand) return { ok:false, assign, remain:slots, used:{} };
    while (need > 0){
      let placed = false;
      for (let i=0;i<slots.length;i++){
        const s = slots[i];
        const usable = cand.filter(d=>canFit(s, d.slot));
        if (!usable.length) continue;
        const pick = usable[0];
        const use = Math.min(need, pick.lv);
        assign.push({ skill: sk, deco: pick.dname, slot: s, lv: use });
        need -= use;
        slots.splice(i,1);
        placed = true;
        break;
      }
      if (!placed) return { ok:false, assign, remain:slots, used:{} };
    }
  }
  return { ok:true, assign, remain:slots, used:{} };
}

// 所持数制限あり
function fillWithDecorationsOwned(slotPool, deficits, skill2decos, ownedMap){
  const slots = [...slotPool].sort((a,b)=>b-a);
  const assign = [];
  const owned = JSON.parse(JSON.stringify(ownedMap || {}));
  const used = {};
  for (const [sk, need0] of Object.entries(deficits)){
    let need = need0;
    const cand = skill2decos[sk];
    if (!cand) return { ok:false, assign, remain:slots, used };
    while (need > 0){
      let placed = false;
      for (let i=0;i<slots.length;i++){
        const s = slots[i];
        const usable = cand.filter(d=> canFit(s, d.slot) && (owned[d.dname]||0) > 0);
        if (!usable.length) continue;
        const pick = usable[0];
        const use = Math.min(need, pick.lv);
        assign.push({ skill: sk, deco: pick.dname, slot: s, lv: use });
        need -= use;
        slots.splice(i,1);
        owned[pick.dname] = (owned[pick.dname]||0) - 1;
        used[pick.dname] = (used[pick.dname]||0) + 1;
        placed = true;
        break;
      }
      if (!placed) return { ok:false, assign, remain:slots, used };
    }
  }
  return { ok:true, assign, remain:slots, used };
}

/** ===================== 不足スキルの発生源ヒント ===================== **/
function showDeficitHints(deficits){
  const fb = document.getElementById("fallback");
  const cont = document.createElement("div");
  cont.innerHTML = `<div class="muted">不足スキルの発生源ヒント</div>`;
  for (const [sk,need] of Object.entries(deficits)){
    const hasDeco = !!DIDX[sk];
    const tops = [];
    for (const part of ["head","chest","arms","waist","legs"]){
      const arr = (AIDX[part]||[])
        .filter(p=> (p.skills[sk]||0)>0)
        .sort((a,b)=> (b.skills[sk]||0) - (a.skills[sk]||0))
        .slice(0,2);
      arr.forEach(p=> tops.push(`${p.name}(+${p.skills[sk]})`));
    }
    const d = document.createElement("div");
    d.className="small";
    d.textContent = `- ${sk}: 装飾品=${hasDeco?'あり':'なし'} ／ 代表防具: ${tops.slice(0,5).join(", ") || "該当なし"}`;
    cont.appendChild(d);
  }
  fb.appendChild(cont);
}

/** ===================== UI状態 ===================== **/
const $ = (q)=>document.querySelector(q);
const skillRoster = {};
let WIDX={}, AIDX={}, DIDX={}, SIDX={};
let DecoCatalog=[];        // [{name, slot, skills}]
let OwnedDecos = {};       // {name: count}
const state = { picked:{}, priorities:{}, weapon:null };

/** ===================== 初期化 ===================== **/
async function bootstrap(){
  // タブ
  const tabSim = document.getElementById("tab-sim");
  const tabOwned = document.getElementById("tab-owned");
  const viewSim = document.getElementById("view-sim");
  const viewOwned = document.getElementById("view-owned");
  tabSim.onclick = ()=>{ tabSim.classList.add("active"); tabOwned.classList.remove("active"); viewSim.style.display="grid"; viewOwned.style.display="none"; };
  tabOwned.onclick = ()=>{ tabOwned.classList.add("active"); tabSim.classList.remove("active"); viewSim.style.display="none"; viewOwned.style.display="block"; };

  // シートID
  const sheetIdInput = $("#sheetId");
  sheetIdInput.value = localStorage.getItem(LS_SHEET_ID) || DEFAULT_SHEET_ID;
  $("#reload").onclick = async ()=>{
    localStorage.setItem(LS_SHEET_ID, sheetIdInput.value.trim());
    await loadAndIndex(sheetIdInput.value.trim());
  };

  // 所持装飾品の反映トグル（既定は前回値／未設定はOFF）
  const useOwned = $("#useOwned");
  useOwned.checked = localStorage.getItem(LS_USE_OWNED) === "1";
  useOwned.onchange = ()=> localStorage.setItem(LS_USE_OWNED, useOwned.checked ? "1" : "0");

  // 所持装飾品のイベント
  $("#ownedFilter").oninput = ()=> renderOwnedList();
  $("#resetOwned").onclick = ()=>{ if (confirm("所持数を全て0にします。よろしいですか？")) { OwnedDecos = {}; saveOwnedDecos(OwnedDecos); renderOwnedList(); } };
  $("#exportOwned").onclick = ()=> downloadText("owned_decorations.json", JSON.stringify(OwnedDecos, null, 2));
  $("#importOwned").onchange = (e)=>{ const f=e.target.files?.[0]; if (f) importOwned(f); e.target.value=""; };
  document.getElementById("maxOwned").onclick = ()=>{
    if (!confirm("全装飾品の所持数をMAXにします。よろしいですか？")) return;
    for (const d of DecoCatalog) OwnedDecos[d.name] = DEFAULT_OWNED_MAX;
    saveOwnedDecos(OwnedDecos);
    renderOwnedList();
  };

  // スキル追加
  $("#addSkill").onclick = ()=>{
    const name = $("#skillPicker").value.trim();
    if (!name || !(name in skillRoster)) return;
    if (!state.picked[name]) state.picked[name] = { target: Math.min(3, skillRoster[name]||3), max: (skillRoster[name]||null) };
    if (!state.priorities[name]) state.priorities[name]=1;
    $("#skillPicker").value="";
    renderPicked(); renderPriorityPanel();
  };

  // 武器選択
  $("#weaponSelect").onchange = ()=>{
    const val = $("#weaponSelect").value;
    state.weapon = val || null;
    const meta = $("#weaponMeta"); meta.innerHTML="";
    if (state.weapon){
      const w = WIDX[state.weapon];
      meta.innerHTML = `<div class="small">スロット: <span class="mono">${w.slots.join("-")||"-"}</span> ／ 武器スキル: ${Object.keys(w.skills).length? JSON.stringify(w.skills):"なし"}</div>`;
    }
  };

  // 実行
  $("#run").onclick = ()=> runSearch();

  // 既存の所持データをロード
  OwnedDecos = loadOwnedDecos();

  // 初回ロード
  await loadAndIndex(sheetIdInput.value.trim());
}

async function loadAndIndex(sheetId){
  const out = $("#result"); out.textContent="読み込み中...";
  const fb = $("#fallback"); fb.textContent="";
  try{
    const {wep, arm, dec, skl, ser} = await loadAll(sheetId);
    // 索引
    Object.assign(skillRoster, buildSkillRoster(skl));
    WIDX = buildWeaponIndex(wep);
    AIDX = buildArmorIndex(arm);
    const d = buildDecoIndexes(dec);
    DIDX = d.s2d; DecoCatalog = d.catalog;
    SIDX = buildSeriesIndex(ser);

    // 初回のみ：所持装飾品をデフォルトMAXで初期化
    if (!localStorage.getItem(LS_OWNED_DECOS)) {
      OwnedDecos = {};
      for (const deco of DecoCatalog) OwnedDecos[deco.name] = DEFAULT_OWNED_MAX;
      saveOwnedDecos(OwnedDecos);
    }

    // UI描画
    renderSkillPicker();
    renderWeapons();
    renderOwnedList();

    // 読み込みサマリ
    const cnt = {
      head: AIDX.head.length, chest: AIDX.chest.length, arms: AIDX.arms.length,
      waist: AIDX.waist.length, legs: AIDX.legs.length
    };
    out.innerHTML =
      `データ読み込み完了。条件を指定して検索してください。<br>` +
      `<span class="small muted">防具件数: 頭${cnt.head} 胴${cnt.chest} 腕${cnt.arms} 腰${cnt.waist} 脚${cnt.legs} ／ `+
      `武器: ${Object.keys(WIDX).length} ／ 装飾品: ${DecoCatalog.length}</span>`;
  }catch(e){
    out.innerHTML = `<span class="error">データ読み込みでエラー: ${e?.message||e}</span>`;
  }
}

/** ===================== 描画 ===================== **/
function renderSkillPicker(){
  const dl = $("#skillList");
  dl.innerHTML = "";
  Object.keys(skillRoster).sort().forEach(n=>{
    const opt = document.createElement("option"); opt.value = n; dl.appendChild(opt);
  });
}
function renderWeapons(){
  const sel = $("#weaponSelect"); sel.innerHTML="";
  const none = document.createElement("option"); none.value=""; none.textContent="（未選択）";
  sel.appendChild(none);
  Object.keys(WIDX).sort().forEach(n=>{
    const op = document.createElement("option"); op.value=n; op.textContent=n; sel.appendChild(op);
  });
}
function renderPicked(){
  const box = $("#pickedSkills"); box.innerHTML="";
  Object.entries(state.picked).forEach(([sk,info])=>{
    const wrap = document.createElement("div");
    wrap.className="row"; wrap.style.alignItems="center";
    const label = document.createElement("div");
    label.className="pill"; label.innerHTML = `<span>${sk}</span><span class="muted">max:${info.max??"?"}</span>`;
    const input = document.createElement("input");
    input.type="range"; input.min="1"; input.max=(info.max||10); input.value=info.target; input.className="grow";
    input.oninput=()=>{ state.picked[sk].target = parseInt(input.value,10); renderPriorityPanel(); };
    const num = document.createElement("span"); num.className="pill"; num.textContent = `Lv${info.target}`;
    input.addEventListener("input", ()=> num.textContent = `Lv${input.value}`);
    const del = document.createElement("button"); del.className="btn bad"; del.textContent="削除";
    del.onclick=()=>{ delete state.picked[sk]; delete state.priorities[sk]; renderPicked(); renderPriorityPanel(); };
    wrap.appendChild(label); wrap.appendChild(input); wrap.appendChild(num); wrap.appendChild(del);
    box.appendChild(wrap);
  });
}
function renderPriorityPanel(){
  const box = $("#priorityPanel"); box.innerHTML="";
  Object.keys(state.picked).forEach(sk=>{
    const row = document.createElement("div"); row.className="row";
    const lbl = document.createElement("div"); lbl.className="pill"; lbl.textContent=sk;
    const sel = document.createElement("select");
    [1,2,3].forEach(v=>{
      const op = document.createElement("option"); op.value=v; op.textContent=v;
      if ((state.priorities[sk]||1)===v) op.selected=true;
      sel.appendChild(op);
    });
    sel.onchange=()=>{ state.priorities[sk]=parseInt(sel.value,10); };
    row.appendChild(lbl); row.appendChild(sel);
    box.appendChild(row);
  });
}

/** ===================== 実行 ===================== **/
function runSearch(){
  const res = $("#result"); const fb = $("#fallback"); res.innerHTML=""; fb.innerHTML="";
  const targets = {}; const prio = {};
  Object.entries(state.picked).forEach(([sk,info])=> targets[sk]=info.target);
  Object.entries(state.priorities).forEach(([sk,v])=> prio[sk]=v);

  const wslots = state.weapon ? WIDX[state.weapon].slots : [];
  const wskills = state.weapon ? WIDX[state.weapon].skills : {};

  // 5部位Greedy
  const picked = greedyPickArmor(AIDX, targets, prio);

  // 表示のベース
  const list = document.createElement("div");
  list.innerHTML = `<div class="muted">選択防具（Greedy）</div>`;
  picked.forEach(p=>{
    const d = document.createElement("div");
    d.className="small mono";
    d.textContent = `- ${p.name}  slots=${p.slots.join('-')||'-'}  skills=${JSON.stringify(p.skills)}  set=${p.set_id||''}`;
    list.appendChild(d);
  });
  if (!picked.length){
    const warn = document.createElement("div");
    warn.className = "small error";
    warn.textContent = "防具候補が0件です。armor_jaのヘッダーや部位名の取り込みに失敗している可能性があります。";
    list.appendChild(warn);
  }
  res.appendChild(list);

  // 合算
  let allSlots = [...wslots];
  for (const p of picked) allSlots.push(...p.slots);
  const total = combineSkills([wskills, ...picked.map(p=>p.skills)]);
  const ser = computeSeriesSkills(SIDX, picked);
  for (const [k,v] of Object.entries(ser)) total[k]=(total[k]||0)+v;

  const deficits = diffTargets(targets, total);

  const useOwned = document.getElementById("useOwned").checked;
  const filled = useOwned
    ? fillWithDecorationsOwned(allSlots, deficits, DIDX, OwnedDecos)
    : fillWithDecorationsUnlimited(allSlots, deficits, DIDX);

  if (Object.keys(ser).length){
    const d = document.createElement("div");
    d.className="small"; d.textContent = `シリーズ発動: ${JSON.stringify(ser)}`;
    res.appendChild(d);
  }
  if (useOwned){
    const d = document.createElement("div");
    d.className="small muted";
    d.textContent = "※ 所持装飾品制限を反映中";
    res.appendChild(d);
  }

  if (filled.ok){
    const ok = document.createElement("div");
    ok.className="success"; ok.textContent="🎉 目標スキルを満たせました";
    res.appendChild(ok);

    const tbl = document.createElement("div");
    tbl.innerHTML = `<div class="muted">装飾品アサイン（skill / deco / slot / +lv）</div>`;
    for (const a of filled.assign){
      const d = document.createElement("div"); d.className="small mono";
      d.textContent = `- ${a.skill} / ${a.deco} / slot${a.slot} / +${a.lv}`;
      tbl.appendChild(d);
    }
    res.appendChild(tbl);

    if (useOwned && Object.keys(filled.used||{}).length){
      const u = document.createElement("div");
      u.innerHTML = `<div class="muted">今回消費した所持装飾品</div>`;
      for (const [nm,c] of Object.entries(filled.used)){
        const d = document.createElement("div"); d.className="small mono";
        d.textContent = `- ${nm}: ${c}個`;
        u.appendChild(d);
      }
      res.appendChild(u);
    }

    if (document.getElementById("optTryUpgrade").checked){
      const remain = filled.remain;
      const upDiv = document.createElement("div");
      upDiv.innerHTML = `<div class="muted">追加で盛れるか探索</div>`;
      let found = false;
      for (const sk of Object.keys(targets)){
        const cur = (total[sk]||0) + filled.assign.filter(a=>a.skill===sk).reduce((s,a)=>s+a.lv,0);
        const mx  = (skillRoster[sk] || 10);
        if (cur < mx){
          const tryAdd = useOwned
            ? fillWithDecorationsOwned(remain, {[sk]:1}, DIDX, OwnedDecos)
            : fillWithDecorationsUnlimited(remain, {[sk]:1}, DIDX);
          if (tryAdd.ok && tryAdd.assign.length){
            found = true;
            const a = tryAdd.assign[0];
            const d = document.createElement("div"); d.className="small mono";
            d.textContent = `- ${sk} / ${a.deco} / slot${a.slot} / +${a.lv}`;
            upDiv.appendChild(d);
          }
        }
      }
      if (!found){
        const nd = document.createElement("div"); nd.className="small muted"; nd.textContent="追加候補は見つかりませんでした。";
        upDiv.appendChild(nd);
      }
      res.appendChild(upDiv);
    }

  }else{
    const bad = document.createElement("div");
    bad.className="error"; bad.textContent="目標スキルを満たせませんでした。";
    res.appendChild(bad);

    const def = document.createElement("div");
    def.className="small mono";
    def.textContent = "不足: " + JSON.stringify(deficits);
    res.appendChild(def);

    if (useOwned && Object.keys(filled.used||{}).length){
      const u = document.createElement("div");
      u.innerHTML = `<div class="muted">今回消費できた所持装飾品（不足のため未達）</div>`;
      for (const [nm,c] of Object.entries(filled.used)){
        const d = document.createElement("div"); d.className="small mono";
        d.textContent = `- ${nm}: ${c}個使用`;
        u.appendChild(d);
      }
      res.appendChild(u);
    }

    // 妥協提案（簡易）
    const lowable = Object.entries(prio).filter(([sk,p])=> p>=2 && deficits[sk]).map(([sk])=>sk);
    const w = document.createElement("div");
    w.innerHTML = `<div class="muted">⑥-1 提案：優先度2/3のスキルを下げると成立する可能性あり</div>
                   <div class="small mono">下げ候補: ${lowable.length? lowable.join(", ") : "該当なし"}</div>`;
    document.getElementById("fallback").appendChild(w);

    const t = document.createElement("div");
    t.className="small muted";
    t.textContent = "⑥-2 鑑定護石提案：シートが用意されていれば拡張可能（本MVPは省略）";
    document.getElementById("fallback").appendChild(t);
  }

  // ★ 不足スキルの発生源ヒントを最後に出す
  if (Object.keys(deficits).length) showDeficitHints(deficits);
}

/** ===================== 起動 ===================== **/
function initialUI(){
  const dl = $("#skillList"); dl.innerHTML="";
  $("#weaponSelect").innerHTML = `<option value="">（未選択）</option>`;
}
initialUI();
bootstrap();
</script>
</body>
</html>
